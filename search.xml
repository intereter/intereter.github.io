<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2020%2F10%2F21%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[在使用动态规划前，要明白两点： 动态规划是将大问题分成小问题。 动态规划采取数组存储各种情况下问题的解。因此，使用动态规划即要回答以下问题： 数组的元素代表什么？ 数组元素之间的关系式？ 初始条件。某些数组元素是否可以直接得到而不用计算？ 例题：lc: 最长回文子串回答3个问题： 数组dp[][]中每个元素代表字符串中下标i到下标j是否为一个回文串 关系式：dp[i][j] = (charArray[i]==charArray[j] &amp;&amp; dp[i+1][j-1])即若字符串为回文串，则其首尾字符相等，且去除首尾后的子串也是回文串 初始条件：长度为1的字符串都是回文串。 123456789101112131415161718192021222324252627282930class Solution &#123; public String longestPalindrome(String s) &#123; char[] charArray = s.toCharArray(); int n = charArray.length; boolean array[][] = new boolean[n][n]; int maxLength = 1; int begin=0,end=0; for(int i=0;i&lt;n;i++)&#123; array[i][i] = true; &#125; for(int j=1;j&lt;n;j++)&#123; for(int i=0;i&lt;j;i++)&#123; if(charArray[j]!=charArray[i])&#123; array[i][j] = false; continue; &#125;else if(j-i&lt;3)&#123;//首尾相等，且该串的子串长度为1或2 array[i][j] = true; &#125;else&#123; array[i][j] = array[i+1][j-1]; &#125; if(array[i][j]&amp;&amp;(j-i+1)&gt;maxLength)&#123; maxLength = j-i+1; begin = i; end = j; &#125; &#125; &#125; return s.substring(begin,begin+maxLength); &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2F2020%2F10%2F05%2F%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归是一种常见的解决问题的方法。问题是，我们怎么实现递归以及分析算法的复杂度呢？先看复杂度的分析:空间复杂度通常与是否递归没有必然联系。空间复杂度至少是O(递归深度)，当然，一些编译(如c,c++，但是java,python不支持)可以对尾递归(即递归调用是递归函数的最后一条指令。尾递归函数可以节省递归调用栈。因为递归调用是函数的最后一条语句，递归调用返回后直接返回而不用进行其他操作，每个递归函数的执行的栈空间大小是一样的，因此栈空间可以重用，进而节省了栈空间)进行优化，使得空间复杂度为O(1)。时间复杂度的分析可以看是否得出时间复杂度的递归关系式。如果没有，时间复杂度可使用O(m)O(n)计算，m为调用次数，n为每次调用的操作次数。如果有，可采用迭代，代入，公式，母函数，差分方程法等，具体如下 现在来看递归的实现：递归的实现通常要有两个条件：基线条件(跳出递归的条件)和递归条件(函数调用自己的条件)。因此，在实现递归时，不要忘了某些特殊点，它们通常用于跳出。另外，在写递归的算法时，要记得执行先后顺序是最底层被调用的先执行]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js函数]]></title>
    <url>%2F2020%2F09%2F23%2Fjs%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在js中，函数也是一个对象。函数可以接受任意个数的参数，可以多于定义的，也可以少于。多于的参数存在函数的rest关键字中，少的以undefined表示。 1234567var abs = function (x) &#123; if (x &gt;= 0) &#123; return x; &#125; else &#123; return -x; &#125;&#125;; 函数有两个重要的关键字：arguments,restarguments类似array但不是array,其中包含了函数所接受到的所有参数。多余的参数以数组的形式交给rest 1234567891011121314151617181920212223function abs() &#123; if (arguments.length === 0) &#123; return 0; &#125; var x = arguments[0]; return x &gt;= 0 ? x : -x;&#125;abs(); // 0abs(10); // 10abs(-9); // 9function foo(a, b) &#123; var i, rest = []; if (arguments.length &gt; 2) &#123; for (i = 2; i&lt;arguments.length; i++) &#123; rest.push(arguments[i]); &#125; &#125; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125; 全局作用域。js只有一个全局作用域。定义的全局对象，如变量，函数都将被绑定到默认的全局对象:window上，作为它的一个属性 局部作用域：通常局部块中的变量作用域是局部作用域。但是js中的var有个奇怪的特性：在for循环中无法使用var定义局部变量.解决方法是用let代替var： 12345678'use strict';function foo() &#123; for (var i=0; i&lt;100; i++) &#123; // &#125; i += 100; // 仍然可以引用变量i&#125; 使用未声明的变量：该变量为undefined,且作用域为全局 结构赋值 1let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; 奇怪的this:this是一个特殊变量，其始终指向当前对象。然而，当前对象是依照情况而定的。在全局中，this指向window。在函数内部的函数，若没有使用strict模式，其指向window,否则指向undefined.解决方法是使用that 1234567891011121314151617181920212223242526272829303132'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined'use strict';var xiaoming = &#123; name: '小明', birth: 1990, age: function () &#123; var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this &#125; return getAgeFromBirth(); &#125;&#125;;xiaoming.age(); // 25]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js快速入门]]></title>
    <url>%2F2020%2F09%2F23%2Fjs%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[这篇文章主要是记录本人在学习javascript时发现的一些简单的,与java不太一样的语言特性的易忘点。 数据类型和变量：js是静态类型语言还是动态类型语言？答案是第二个。在js中，变量的类型是通过值判定的。数据类型:number:包括整数，浮点数,NaN(not a number),infinity(无限)null与undefined: 在js中，null和undefined很相似。其中null表示一个空值，undefined表示值未定义。但通常undefined没什么卵用，用null最好strict模式：在js中，有很神奇的一点是，变量未声明即可使用。在其未声明即使用的情况下，该变量默认是全局变量。这说明，如果乱用未声明变量，会造成很大困扰。因此，在js中引入了strict模式，只要在代码开头写上 “use strict”，强制使用var 定义变量 对象在js中，对象是键值对的集合，其中键必须是字符串，例如 12345678var xiaoming = &#123; name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null&#125;; 在js中访问一个对象不存在的属性会发生什么呢？js不会报错，只会返回undefined 迭代：for(x in array)，for(x of array)和forEach()以上三种方法都可以迭代一个数组，map或set。但使用forEach是最好的。使用for(..in..)实际上是遍历属性，若如下会出现奇特的现象。而for(..of..)修好了这个问题。12345var a = ['A', 'B', 'C'];a.name = 'Hello';for (var x in a) &#123; console.log(x); // '0', '1', '2', 'name'&#125; forEach需要传入一个回调函数 1234567891011121314a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index);&#125;);var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map) &#123; console.log(value);&#125;);]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[通过前序遍历和中序遍历构造二叉树]]></title>
    <url>%2F2020%2F09%2F23%2Fs%E9%80%9A%E8%BF%87%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[使用递归法可以很简单的解决该问题。递归的大致思路是：先生成根，再构造左子树和右子树。在做这道题时，我也很快想到了该方法，但疑问的是，仅仅通过知道左子树的前序，中序集合和右子树的前序，中序集合，怎样连接二叉树呢？答案是递归的最底层：当只有一个节点,生成该节点，在这一层的上层递归会连接该节点，从而一步步递归成为树。下面是解决该问题的代码。 1234567891011121314151617181920212223242526272829public class rebuildTree &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;inorder.length;i++)&#123; map.put(inorder[i],i); &#125; TreeNode root = buildTree(preorder,0,preorder.length-1,inorder,0,inorder.length-1,map); return root; &#125; public TreeNode buildTree(int[] preorder, int preStart, int preEnd, int [] inorder, int inStart, int inEnd, Map&lt;Integer,Integer&gt; map)&#123; TreeNode root = new TreeNode(preorder[preStart]); //通过这个判断可以解决一个问题：在前序遍历中，与root右边相邻的是左子树根节点还是右子树根节点。若start&gt;end,虽然在下面有构造左子树的操作，但通过这里的判断可知左子树是不存在的，返回null if(preStart &gt; preEnd)&#123; return null; &#125; if(preStart == preStart) return new TreeNode(preorder[preStart]); else &#123; int rootNum = map.get(preorder[preStart]); int leftNum = rootNum - inStart; int rightNum = inEnd - rootNum; TreeNode leftNode = buildTree(preorder,preStart+1,preStart+leftNum,inorder,inStart,rootNum-1,map); TreeNode rightNode = buildTree(preorder,preStart+leftNum+1,preEnd,inorder,rootNum+1,inEnd,map); root.left = leftNode; root.right = rightNode; return root; &#125; &#125;&#125; 时间复杂度：O(n)。对于每个节点都有创建过程以及根据左右子树重建过程。空间复杂度：O(n)。存储整棵树的开销。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列]]></title>
    <url>%2F2020%2F09%2F02%2F%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[求斐波那契数列的值与1e9+7的模 ，使用递归太耗费时间，可以采用动态规划什么是动态规划，一言以蔽之就是将问题拆分为多个子问题，得到f(n)与f(n-1),f(n-2)….的关系式(可用这么理解，要得到f(n)就先考虑f(n-1)，比如青蛙跳台阶问题。青蛙可一次跳两层，也可一次跳一层，所以对应f(n)，青蛙可以从n-1或n-2跳上来，因此青蛙跳上n层台阶的方法总数为f(n) = f(n-1)+f(n-2))，并求得初始值(指不满足关系式，必须人工求得的值)，即可求得题目要求的f(n)更好的动态规划的解释例如这里的求斐波那契数列的值，题目已经给出关系式f(n)=f(n-1)+f(n-2)和初始值f(0) = 0,f(1) = 1。我们可以利用数组存储f(0)到f(n)的值，只要顺序遍历i=2到i=n,利用关系式即可求出f(n)当然，这道题不仅仅只考动态规划，还考了大数处理。当f(n)很大时，其可能超过int所能表示的值，造成所得为负数，所以这里我们需要利用模运算的性质可得，f(n)%(1e9+7) = (f(n-1)+f(n-2))%(1e9+7) = (f(n-1)%(1e9+7)+f(n-2)%(1e9+7)) 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int fib(int n) &#123; int []array = new int[101]; array[0] = 0; if(n&gt;=1) array[1] = 1; for(int i =2;i&lt;n+1;i++)&#123; array[i] = array[i-1] + array[i-2]; array[i] = array[i]%1000000007; &#125; return array[n]; &#125;&#125;``` 也可以不用数组存储，因为只要求f(n),可用a,b两值分别代表f(n-2),f(n-1),并迭代```javaclass Solution&#123; public int fib(int n)&#123; int a=0; int b=1; if(n==0) return 0; if(n==1) return 1; while(n&gt;=2)&#123; int temp = b%1000000007; b = (a+b)%1000000007; a= temp%1000000007; n--; &#125; return b; &#125;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组中重复的数字]]></title>
    <url>%2F2020%2F09%2F01%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目：找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 这是一道简单题。下面记录两种解题方法： 利用for循环遍历数组，对每个数字尝试添加到hash表，添加失败即为重复。时间复杂度为o(n),其中遍历为o(n)，hash的add操作是时间复杂度为o(1)的操作。 12345678910public int findRepeatNumber(int[] nums) &#123; int num = 0; Set set = new HashSet(); for(int i: nums)&#123; if(!set.add(i))&#123; num = i ; break; &#125; &#125; return num;&#125; 剑指offer的标准答案：在给出的数组中遍历，如nums[ i ] == i,跳过，i++，否则继续。判断是否满足nums[ i ] == nums[ nums[ i ]],如果满足则说明重复，否则继续。将nums[ i]与 nums[ nums[ i]]交换。时间复杂度也是o(n),关键在于相对于上面的解法，没有开辟新的表，空间复杂度是常数。这是一个很好的思路： 在给定的数组中操作可以节省空间 123456789101112131415161718192021public int findRepeatNumber(int[] nums) &#123; int repeat = -1; int i = 0; while(i&lt;nums.length)&#123; if(nums[i] == i)&#123; i++; continue; &#125; if( nums[i] == nums[nums[i]]) return nums[i]; int temp = nums[i]; nums[i] = nums[temp]; nums[temp] = temp; &#125; return repeat;&#125;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验1]]></title>
    <url>%2F2020%2F07%2F07%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C1%2F</url>
    <content type="text"><![CDATA[Linux 本身只是操作系统的内核。内核是使其它程序能够运行的基础。它实现了多任务和硬件管理，用户或者系统管理员交互运行的所有程序实际上都运行在内核之上。其中有些程序是必需的，比如说，命令行解释器（shell），它用于用户交互和编写 shell 脚本。 Linus 没有自己去开发这些应用程序，而是使用已有的自由软件。 Linux 本身只是操作系统的内核。内核是使其它程序能够运行的基础。它实现了多任务和硬件管理，用户或者系统管理员交互运行的所有程序实际上都运行在内核之上。其中有些程序是必需的，比如说，命令行解释器（shell），它用于用户交互和编写 shell 脚本。 Linus 没有自己去开发这些应用程序，而是使用已有的自由软件。 Linux 本身只是操作系统的内核。内核是使其它程序能够运行的基础。它实现了多任务和硬件管理，用户或者系统管理员交互运行的所有程序实际上都运行在内核之上。其中有些程序是必需的，比如说，命令行解释器（shell），它用于用户交互和编写 shell 脚本。 Linus 没有自己去开发这些应用程序，而是使用已有的自由软件。 Linux桌面环境介绍：Linux没有图形界面，现在所在桌面上看到的图形界面实际上是运行在Linux系统上的一套软件，过去是XFree86，现在是xorg(实现了X协议规范的一个提供图形界面服务的服务器)。有了服务器，还有油客户端。我们称为X Client 终端：通常我们在使用 Linux 时，并不是直接与系统打交道，而是通过一个叫做 Shell( 提供给使用者使用界面”的软件（命令解析器），类似于 DOS 下的 command（命令行）和后来的 cmd.exe 。) 的中间程序来完成的，在图形界面下为了实现让我们在一个窗口中完成用户输入和显示输出，Linux 系统还提供了一个叫做终端模拟器的程序（Terminal）。 终端本质上是对应着 Linux 上的 /dev/tty 设备，Linux 的多用户登录就是通过不同的 /dev/tty 设备完成的，Linux 默认提供了 6 个纯命令行界面的 “terminal”（准确的说这里应该是 6 个 virtual consoles）来让用户登录。（一个用户打开多个终端，产生的是伪终端） Shell通常在图形界面中对实际体验带来差异的不是上述的不同发行版的各种终端模拟器，而是这个 Shell（壳）。有壳就有核，这里的核就是指 UNIX/Linux 内核，Shell 是指“提供给使用者使用界面”的软件（命令解析器），类似于 DOS 下的 command（命令行）和后来的 cmd.exe 。UNIX/Linux 操作系统下的 Shell 既是用户交互的界面，也是控制系统的脚本语言。在 UNIX/Linux 中比较流行的常见的 Shell 有 bash、zsh、ksh、csh 等等，Ubuntu 终端默认使用的是 bash。 Linux用户管理查看用户：whoami 文件:linux中一切皆文件。在 Linux 中文件的类型不是根据文件后缀来判断的。当你在文件里输入内容后才会显示文件类型。列出文件: ls -l查看文件： cat filename Linux目录结构Linux 的目录与 Windows 的目录的区别，或许对于一般操作上的感受来说没有多大不同，但从它们的实现机制来说是完全不同的。 一种不同是体现在目录与存储介质（磁盘，内存，DVD 等）的关系上，以往的 Windows 一直是以存储介质为主的，主要以盘符（C 盘，D 盘…）及分区来实现文件管理，然后之下才是目录，目录就显得不是那么重要，除系统文件之外的用户文件放在任何地方任何目录也是没有多大关系。所以通常 Windows 在使用一段时间后，磁盘上面的文件目录会显得杂乱无章（少数善于整理的用户除外吧）。然而 UNIX/Linux 恰好相反，UNIX 是以目录为主的，Linux 也继承了这一优良特性。 Linux 是以树形目录结构的形式来构建整个系统的，可以理解为树形目录是一个用户可操作系统的骨架。虽然本质上无论是目录结构还是操作系统内核都是存储在磁盘上的，但从逻辑上来说 Linux 的磁盘是“挂在”（挂载在）目录上的，每一个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。举例来说，可以利用网络文件系统（Network File System，NFS）服务器载入某特定目录等。 Linux目录结构采用FHS标准 Linux文件操作创建文件： touch创建文件夹： mkdir复制： cp移动(重命名)： mv删除: rm linux查看帮助文档进入bash, 例如ls –help或使用man,例如 man ls或使用info,例如 info ls]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js西电学堂]]></title>
    <url>%2F2020%2F06%2F17%2Fjs%E8%A5%BF%E7%94%B5%E5%AD%A6%E5%A0%82%2F</url>
    <content type="text"><![CDATA[数据类型js中数字只有浮点数类型undifined类型 ==引起的类型转换使得它不常用 变量类型：动态可变]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css常用实现]]></title>
    <url>%2F2020%2F06%2F17%2Fcss%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[如何实现圆角边框： 1234567.testRadius&#123; width: 150px; height: 100px; border: 20px solid red; border-radius: 100px; /* 设置border-radius为100px即可 */&#125; 类选择器 123456.test&#123; /*test类的修饰*/&#125;li.test&#123; /*test类的li元素修饰*/&#125; 根据元素位置确定样式 12345678/* li内部的em元素 */li em &#123; color: rebeccapurple;&#125;/* 出现在h1后面，并与h1有相同层级的修饰 */h1 + p &#123; font-size: 200%;&#125; 根据元素状态确定样式 1234567891011/* a标签未访问，访问，悬停三个状态的修饰 */a:link &#123; color: pink;&#125;a:visited &#123; color: green;&#125;a:hover &#123; text-decoration: none;&#125; 设置字体居中 1text-align : center 字体自适应大小：了解rem,vw 设置组件居中 1234567/* 弹性盒子布局 */.dayCase&#123; display: flex; align-items: center; justify-items: center; text-align: center;&#125; 设置文字居中: text-align: center 是使文字水平居中。若要垂直居中，则使文字包裹在块级元素内，再使用第七条 设计一个有遮罩层的弹窗：弹窗实际上是设计一个覆盖整个页面的容器，容器内包含的内容即我们眼睛看到的弹窗。在这个设计中，我们把覆盖的容器叫做弹窗。将该容器的背景颜色设计为半透明，则是遮罩层。 123456789&lt;div class="popUpWindows"&gt; &lt;div class="popUpWindowsContent" id="chefPopUpWindow"&gt; &lt;h1&gt;招聘新厨师&lt;/h1&gt; &lt;p&gt;招聘一名新厨师可以帮你更快的为顾客烹饪菜肴，&lt;br&gt; 增加餐厅收入。你最多可以拥有六名厨师。&lt;br&gt; 但每个厨师需要你每周支付工资￥100&lt;br&gt; 请问你确认新招聘一名厨师吗？&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930.popUpwindows&#123; display: none; /* display: flex; */ position: fixed; /* 固定定位 */ z-index: 1; /* 设置在顶层 */ left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgb(0,0,0); /* rgba,a指alpha，是不透明度参数 */ background-color: rgba(0,0,0,0.4); align-items: center; justify-items: center;&#125;.popUpwindowsContent&#123; display: flex; margin: auto; width: 90%; height: 35%; /* display: flex; */ flex-direction: column; align-items: center; /* justify-content: center; */ text-align: left; background-color:rgb(243, 213, 41) ; border: 20px solid white; border-radius: 50px; &#125; 实现颜色的突变：使用linear-gradient渐变 123.test&#123;background-image: linear-gradient(to right, rgb(255, 166, 0) 50%, rgb(238, 120, 10) 50%);&#125; 实现右上角的叉叉：实际上是+号旋转45度 1234567.fireChef&#123; position: relative; left: 80%; bottom: 100%; font-size: 80px; transform: rotate(45deg);&#125; 实现进度条：怎样实现动态加载？怎样使文字固定在进度条中间？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 进度条由三部分组成：进度条容器，进度，文字实现动态加载是为进度添加一个动画使文字处于进度条中间需要相对定位，文字容器的width=100%和z-index处于较大而优先 */.chefProgressBar&#123; margin-left: auto; margin-right: auto; margin-top: -15%; width: 80%; height: 15%; text-align: center; display: flex; position: relative; background-color: rgb(255, 166, 0); color:white; border: 5px solid white; border-radius: 10px; &#125;.chefFill&#123; animation: move 10s; background-color: rgb(238, 120, 10); height: 100%; position: absolute; left: 0; top: 0; z-index: 1;&#125;@keyframes move&#123; 0%&#123; width: 0%; &#125; 100%&#123; width: 100%; &#125;&#125;.chefDish&#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%; z-index: 10; font-size: 30px; &#125; 12345&lt;div class="chefProgressBar"&gt; &lt;div class="chefDish"&gt;小程序奶茶&lt;/div&gt; &lt;div class="chefFill"&gt; &lt;/div&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chrome搜索技巧]]></title>
    <url>%2F2020%2F06%2F15%2Fchrome%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[这篇文章主要记录搜索中的技巧。通过在搜索内容中使用一定的格式搜索而得到特定范围的搜索内容。 “关键字”作用：关键字限定 关键字 空格 减号关键字例：key -anotherkey搜索不包含anotherkey的内容 关键字 site:网站例：key site:zhihu.com仅在知乎内搜索key 关键字 filetype:type例： 算法导论 filetype:pdf搜索某种格式的文件 intext: / allintext:例：intext:海绵宝宝 正文中一定出现海绵宝宝这个关键字例 allintext:海绵宝宝 派大星 正文中同时出现海绵宝宝，派大星两个关键字 inurl:key顾名思义，不再解释 intitle:key同上]]></content>
      <categories>
        <category>前置技能</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[远见：如何规划职业生涯三大阶段]]></title>
    <url>%2F2020%2F06%2F14%2F%E8%BF%9C%E8%A7%81%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E4%B8%89%E5%A4%A7%E9%98%B6%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[part1:远见思维与工具箱 多行动，少忧虑 职业生涯很长，重要的是能力的培养而不是一时的升职加薪。不要单单把职场生活视为一份工作，而是一段职业生涯，不断锻炼自己的能力 职业生涯分为3个阶段：强势开局： 锻炼应该有的能力，补足短板，建立良好的早期习惯,建立关系网，积攒经验聚焦长板：专注于自己的核心优势，寻找热爱，擅长，世界所需要的交集持续的影响力： 职场燃料：可迁移技能，有意义的经验，持久的关系可迁移技能：解决问题的能力，说服力，人才引力，快速学习的能力和应试能力，如何通过呼吸来放松于专注，帮助他人的能力(付出是建立信任的好方法)，搜索信息的能力有意义的经验：项目持久的关系：上司，雇主，身边的人才，同类，商业伙伴 职业生涯的时间投资：如何通过刻意练习成为大师？我的时间都放在了哪里? 四大黄金问题：是否正在学习与成长？ 是否得到了奖励，创造了经济价值，是否体验到乐趣，是否对人，公司，社会拥有影响力 总结：找到理想目标，多行动，少忧虑。培养专业技能，可迁移技能，有意义的经验和持久的关系。运用合理的时间投资，刻意练习自己的技能。人生很长，不仅仅是码农而已，也不仅仅是互联网。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[springLearning_5:spring-thymeleaf]]></title>
    <url>%2F2020%2F06%2F09%2FspringLearning-6-spring-thymeleaf%2F</url>
    <content type="text"><![CDATA[thymeleaf的配置：12345678&lt;!-- pom.xml --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;!-- thymeleaf-spring&#123;$version&#125; --&gt; &lt;!-- version与spring当前使用的版本一代 --&gt; &lt;version&gt;3.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// config@Autowiredprivate ApplicationContext applicationContext; @Bean public SpringResourceTemplateResolver templateResolver()&#123; // SpringResourceTemplateResolver automatically integrates with Spring's own // resource resolution infrastructure, which is highly recommended. SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver(); templateResolver.setApplicationContext(this.applicationContext); templateResolver.setPrefix("/WEB-INF/templates/"); templateResolver.setSuffix(".html"); // HTML is the default value, added here for the sake of clarity. templateResolver.setTemplateMode("HTML5"); // Template cache is true by default. Set to false if you want // templates to be automatically updated when modified. templateResolver.setCacheable(true); return templateResolver; &#125; @Bean public SpringTemplateEngine templateEngine()&#123; // SpringTemplateEngine automatically applies SpringStandardDialect and // enables Spring's own MessageSource message resolution mechanisms. SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver()); // Enabling the SpringEL compiler with Spring 4.2.4 or newer can // speed up execution in most scenarios, but might be incompatible // with specific cases when expressions in one template are reused // across different data types, so this flag is "false" by default // for safer backwards compatibility. templateEngine.setEnableSpringELCompiler(true); return templateEngine; &#125; @Bean public ThymeleafViewResolver viewResolver()&#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setTemplateEngine(templateEngine()); // NOTE 'order' and 'viewNames' are optional viewResolver.setOrder(1); //setViewNames这里注释掉，与官网不一样。似乎是导致view后缀重复？ //viewResolver.setViewNames(new String[] &#123;".html", ".xhtml"&#125;); return viewResolver; &#125; 基本用法官方文档]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[springLearning_5:spring-jdbc]]></title>
    <url>%2F2020%2F06%2F07%2FspringLearning-5-spring-jdbc%2F</url>
    <content type="text"><![CDATA[管理jdbc连接：使用DataSource接口，该接口有多种实现类。需要配置jdbcurl,user,password等 jdbcTemplate: 传入DataSource.是一个简化crud的类。]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[springLearning_4:注解的使用]]></title>
    <url>%2F2020%2F05%2F31%2FspringLearning-4-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[bean用于修饰配置类中的方法，该方法可以返回一个作为bean的类（在项目设计中，是每个作为组件的类发挥作用，而不是主入口类） autowired,component,componentScanautowired用于修饰一个属性，表示该属性自动装配。当容器扫描到有带有component修饰的类时，装配。component修饰一个类，表示该类自动被扫描componentScan修饰配置类。spring中的注解]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[springLearning_3:springmvc初学]]></title>
    <url>%2F2020%2F05%2F28%2FspringLearning-3-springmvc%E5%88%9D%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[什么是spring mvc: 一种设计模式m: model,模型。指返回的数据对象(一张表)，用于传给视图做视图渲染(什么是视图渲染？继续往下看)v: view，视图。是用来表示web交互的接口视图对象经过渲染后通过页面展示给用户。c: controller mvc的工作流程：（1）客户端（浏览器）发送请求，直接请求到 DispatcherServlet。 （2）DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。 （3）解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。 （4）HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑。 （5）处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。(逻辑上的view是什么意思？) （6）ViewResolver 会根据逻辑 View 查找实际的 View。 （7）DispaterServlet 把返回的 Model 传给 View（视图渲染）。 （8）把 View 返回给请求者（浏览器） 另一种说法，或许更清晰1.发起请求到前端控制器(DispatcherServlet)2.前端控制器请求处理器映射器(HandlerMapping)查找Handler(可根据xml配置、注解进行查找)3.处理器映射器(HandlerMapping)向前端控制器返回Handler4.前端控制器调用处理器适配器(HandlerAdapter)执行Handler5.处理器适配器(HandlerAdapter)去执行Handler6.Handler执行完，给适配器返回ModelAndView(Springmvc框架的一个底层对象)7.处理器适配器(HandlerAdapter)向前端控制器返回ModelAndView8.前端控制器(DispatcherServlet)请求视图解析器(ViewResolver)进行视图解析，根据逻辑视图名解析成真正的视图(jsp)9.视图解析器(ViewResolver)向前端控制器(DispatcherServlet)返回View10.前端控制器进行视图渲染，即将模型数据(在ModelAndView对象中)填充到request域11.前端控制器向用户响应结果 springMVC重要组件说明：需要自己实现的：Handler:即controller,要按照HandlerAdapter的要求实现。HandlerMapping通过url来查找Handler。view：一个接口，实现支持不同的view类型，如jsp,pdf,freemarker 不需自己实现，框架提供：前端控制器DispatcherServlet（不需要工程师开发）,由框架提供。作用：Spring MVC 的入口函数。接收请求，响应结果，相当于转发器，中央处理器。有了 DispatcherServlet 减少了其它组件之间的耦合度。用户请求到达前端控制器，它就相当于mvc模式中的c，DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。 处理器映射器HandlerMapping(不需要工程师开发),由框架提供作用：根据请求的url查找Handler。HandlerMapping负责根据用户请求找到Handler即处理器（Controller），SpringMVC提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器适配器HandlerAdapter作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 视图解析器View resolver(不需要工程师开发),由框架提供作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。 现在接触到项目较简单，并没有使用handlerAdapter封装handler,以后或许接触了会懂（适配器模式？？）。springMVC有使用默认的handlerMapping: BeanNameUrlHandlerMapping,也可以自己配置 springMVC的使用前配置：123456789101112131415161718192021222324&lt;!-- ContextLoaderListener用于初始化Ioc容器，实现spring支持，装配AppicationContext。疑问： bean和servlet怎么区分和安排？ --&gt;&lt;!-- 解答：同配置在DispatchServlet的webApplicationContext中？ --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;!-- 如果不设置init-param标签，则必须在/WEB-INF/下创建xxx-servlet.xml文件，其中xxx是servlet-name中配置的名称。 --&gt; &lt;!-- springmvc-servlet.xml指的是各种servlet的配置文件吗？ --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- load-on-startup这个元素表示是否在容器初始化时就加载这个servlet。当其为正整数，则加载，值越小，则加载的优先度越高。该元素不写或小于0，则在调用时才加载。 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[maven使用过程中碰到的各种坑]]></title>
    <url>%2F2020%2F05%2F28%2Fmaven%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%A2%B0%E5%88%B0%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91%2F</url>
    <content type="text"><![CDATA[下载依赖：下载速度慢： 查看maven使用的settings.xml文件，修改为国内镜像源 12345678910&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;!-- 国内推荐阿里云的Maven镜像 --&gt; &lt;!-- &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; --&gt; &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 无法下载：failed to transfer ……可能原因： 防火墙未运行你使用的ide通过 下载时需要检查ssl证书。在idea - file -settings - build,execution,depl - maven importing -vm options for importer修改为 ： -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true 即可忽略ssl检验 build:找不到主类或无法加载：控制台执行： mvn idea: idea。若出现无法下载依赖，则可能也是ssl证书检验的问题，执行时加上选项，为：mvn idea: idea -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Dmaven.wagon.http.ssl.ignore.validity.dates=true compile:Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1一种解决方式(针对这次遇到的情况)：在maven的settings.xml文件中添加以下配置jdk1234567891011&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;custom-compiler&lt;/id&gt; &lt;properties&gt; &lt;JAVA_HOME&gt;C:\Program Files\Java\jdk-11.0.2&lt;/JAVA_HOME&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;custom-compiler&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 在项目pom.xml添加以下： 1234567891011121314&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;executable&gt;$&#123;JAVA_HOME&#125;/bin/javac&lt;/executable&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 解决 controller mvn addObject not show in jspmaven 自动生成的web.xml文件有问题，修改头：123456&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; 但是上述的参数意义是什么？]]></content>
      <categories>
        <category>maven</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[springLearning_2:使用spring进行依赖注入]]></title>
    <url>%2F2020%2F05%2F27%2FspringLearning-2-%E4%BD%BF%E7%94%A8spring%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[说在前头：spring的工作是配置容器，然后实例化容器，由容器完成工作。 spring Ioc容器：配置容器：即提供容器配置组件的信息，这些信息叫元数据。有三种配置方法：基于java类的配置：编写各个组件，编写配置类(带有注解：@configruation),在main方法中将配置类作为参数实例化容器类基于xml的配置：在xml文件中编写配置信息，在main方法中将xml文件作为参数实例化容器类两者结合： 将配置类写入xml文件中，在main方法中将xml文件作为参数实例化容器类注：yml文件？ 依赖注入： //setter &lt; bean id = “…” class = “”&gt; &lt; !– 注入bean –&gt; &lt; property name = “” ref=””/&gt; &lt; !– 注入属性值 –&gt; &lt; propety name =”” value = “”/&gt; &lt; /bean&gt; //constructor &lt; bean id = “” class = “”&gt; &lt; !– 指由第一个constructor方法创建 –&gt; &lt; constructor-arg ref=”” index = “0”/&gt; &lt; constructor-arg value = “”/&gt; &lt; /bean&gt; //不建议在配置中使用循环依赖 //其结果是，两者拥有对方创建不完全的实例的引用 class A{ B b; public A(B b){ this.b = b; } } class B{ A a; public B(A a){ this.a = a; } } 一个bean在未完全创建时是不会作为一个依赖项注入到其他bean中的。容器创建过程： 先处理配置元数据，创建bean定义并验证定义。然后完成bean的创建和依赖注入 depends-on特性：b depend on a,使a在b前被创建 自动装配：@Autowired:我们一般使用 @Autowired 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,可以采用以下注解实现： @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。 @Autowired private UserService userService; Spring管理的bean:bean的命名：具有两个特性：id和name。id只有一个，name可有多个。若同时设置id,name，则id是标识符，name是别名。设置多个name,第一个是标识，其他是别名。如何设置：xml文件中填写特性或利用注解传入string标识符，别名都是唯一的 bean的实例化：使用constrructor(通常在xml中配置),工厂方法(可使用注解) bean与component的区别：component：利用spring 类路径扫描，写在类上，和类定义不分离，不需要配合 @configuration注解bean:写在工厂方法上，配合@configuration的注解 bean的作用域：即bean的生命周期，使用@scope或scope特性设置，分为：singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。prototype : 每次请求都会创建一个新的 bean 实例。request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringLearning_1]]></title>
    <url>%2F2020%2F05%2F26%2FSpringLearning-1%2F</url>
    <content type="text"><![CDATA[(2020.5.26 配置maven中webapp的web.xml出错：配置文件首行不为空，否则报错) pojo(plain old java object): 简单，快速的编写应用类的模型。无依赖特定api（大概指的是独立模块？） 容器： 创建，装配组件，提供中间件服务(aop,例如日志？)的环境。什么是轻量级容器，何谓轻量级。容器和组件的关系是可插拔的(选择装配)，由容器实例将依赖组件注入组件 控制反转(Ioc):指对依赖项的控制由组件转到容器实例。两种形式：依赖查找与依赖注入。从上下文中查找依赖项。通过setter,构造函数注入依赖。我们关心第二种setter方法，构造函数的比较：setter: 优点，可以在组件生成后重新配置。缺点，不是所有属性可以在组件开始使用前被配置，set顺序很重要。构造函数：优点，组件生成前完成配置，一致性高。缺点，无法重新配置 上下文：指当前程序运行的整个环境，包含了状态，资源等。]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lambda表达式和在java中的应用]]></title>
    <url>%2F2020%2F05%2F21%2Flambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%9C%A8java%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.意义：相当于一个匿名函数的实现 格式： //若无参数，括号内为空。一个参数，可省去括号 //若body为单句，可以省去大括号 ()-&gt;{ body } (parameters..)-&gt;{ body } 作用：可以传给只有单个需实现方法的接口，完成实例化，例： Runnable run = ()-&gt;system.out.printn(“test”);]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java扫盲]]></title>
    <url>%2F2020%2F05%2F21%2Fjava%E6%89%AB%E7%9B%B2%2F</url>
    <content type="text"><![CDATA[j2se,j2me,j2ee: 标准版，微型，商用。java5.0后，称为java se,me,ee 版本号： java 1.8:指 jdk 8]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java多线程1]]></title>
    <url>%2F2020%2F05%2F20%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[为什么要使用线程池：因为线程的创建于关闭开销大，不能频繁的创建，关闭。将线程放到池子中复用是一个解决方法 Volatile关键字：使修饰的对象具有可见性（不同线程之间的可见。即线程a对变量t修改，线程b能立刻读到t的修改得到的最新值）为什么具有可见性：对于变量t，线程a,b都只是修改了副本。真正的t存在内存中。被volatile修饰的对象能在修改后立刻同步到内存，并让线程b在读取t时到内存中读取。什么时候可以使用这种看起来不是很安全的关键字：一些变量的修改与当前值无关的，比较简单的，例如某个作为标志的布尔值 大佬的博客 3.syncronized关键字：利用内部锁，使修饰的代码在同一时间只能由一个线程进入。内部锁：java中，每个对象都有一个内部锁。锁的持有对象是线程，当线程持有这个锁时，其他线程不能进入这段代码。用法: //这个this指此时调用这个方法的实例对象的锁 syncronized(this){ count++; } //也可以使用任意一个对象的锁，不过这个对象在调用的方法的对象里 syncronized(object){ ... }显式锁：Lock lock..syncrinized的原子性和可见性 Future与FutureTask，CallAbleCallAble是接口，要实现call方法Future是接口，FutureTask是它的实现类初始化需要一个CallAble对象，通过get方法获得计算结果（get返回的是CallAble的call）]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jdbcLearning]]></title>
    <url>%2F2020%2F04%2F22%2FjdbcLearning%2F</url>
    <content type="text"><![CDATA[步骤：导入MySQL或者Oracle驱动包(在idea中需要往项目中导入mysql的连接包，具体方法时打开file-project Structure-dependencies)装载数据库驱动程序获取到与数据库连接获取可以执行SQL语句的对象执行SQL语句关闭连接 加载驱动：实质就是加载驱动类，完成驱动类在jvm中的加载，因此驱动类中的静态代码块被执行，而代码块中有真正注册的方法。 Class.forName(“com.mysql.jdbc.Driver”); //8.0 “com.mysql.cj.jdbc.Driver” 获取连接：url中要注明时区： serverTimezone. 使用无密码登录时密码为空,例：jdbc:mysql//localhost:dbname?serverTimezone=UTC; //UTC是全球标准时间 //1 DriverManager.getConnection(url); //2 DriverManager.getConnection(url,infos); //3 DriverManager.getConnection(url,user,password); preparedStatement: 预编译sql语句，填写占位符，执行(通过preparedStatement可以防注入)。对于单个sql语句来说是单例的pre = connection.getPreparedStatement(sql);pre.setInt(序号,number);pre.excuteQuery();//批处理： Batchpre.addBatch();pre.executeBatch();]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[会话技术]]></title>
    <url>%2F2020%2F04%2F20%2F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[什么是会话： 浏览器访问服务器，直到关闭浏览器，这是一次会话 cookie: 客户端会话技术。相当于服务器暂存在浏览器的数据。当服务器需要浏览器的一些用户信息时，会使用responce向浏览器发送cookie,浏览器将cookie保存。下次访问服务器时将请求的网址和cookie一起交给服务器。cookie只能存储字符串(ascll编码)，session能存储任何类型数据几个属性：MaxAge: cookie存在的最大时间。为正数，保存在浏览器本地，在小于该时间内该cookie有效。为0，删除该cookie,为负数，临时cookie。domain: cookie的域名。不能跨域名提供cookie。path: 决定某个cookie当访问某个路径下资源时才提供给服务器 session: 保存在服务器内存中的域对象，当用户访问服务器的servlet会生成，servlet间共享，超过超时时间会被删除。session通过cookie(名称：JESSIONID)识别用户]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[url,uri]]></title>
    <url>%2F2020%2F04%2F20%2Furl-uri%2F</url>
    <content type="text"><![CDATA[uri: 统一资源标志符。指的是资源的在某个规则下独一无二的名字 url: 资源的位置，也同样是唯一的，可以表示一个资源的身份。url相当于uri的子集。一个url包括协议+访问主机的名字，端口号等+资源的具体位置和参数]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计网实验课1]]></title>
    <url>%2F2020%2F04%2F17%2F%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C%E8%AF%BE1%2F</url>
    <content type="text"><![CDATA[实验1 访问cisco网络设备 路由器：2611交换机：2960 enabl进入授权模式mac地址：网络设备的物理地址ip地址：网络设备的虚拟地址 路由器与路由器，交换机遇交换机用虚线连接路由器与交换机有平行线连接 在子网内才能ping通]]></content>
      <categories>
        <category>计网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ServletLearning]]></title>
    <url>%2F2020%2F04%2F16%2FServletLearning-0%2F</url>
    <content type="text"><![CDATA[定义 ： 什么是servlet服务器与数据库的中间层。已经有Servlet的类实现。其用于处理浏览器的请求和发送回复 一个servlet程序(类)的结构：init()：初始化service():服务逻辑destroy():销毁。当关闭tomcat服务器时才调用ServletConfig：Servlet配置getServletInfo：Servlet信息 servlet配置：告诉tomcat服务器使用哪个类做servlet. servlet的映射路径。外界访问servlet的路径 1234567891011&lt;!-- servlet容器的名字和类名(存放位置)--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!-- servlet容器的映射路径--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- 外界访问servlet容器的路径--&gt; &lt;url-pattern&gt;/HelloServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; tomcat生命周期：加载Servlet。当Tomcat第一次访问Servlet的时候，Tomcat会负责创建Servlet的实例初始化。当Servlet被实例化后，Tomcat会调用init()方法初始化这个对象处理服务。当浏览器访问Servlet的时候，Servlet 会调用service()方法处理请求销毁。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，让该实例释放掉所占的资源。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁卸载。当Servlet调用完destroy()方法后，等待垃圾回收。如果有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作。简单总结：**只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用。 servlet细节： 一个servlet可以被多个url映射。在web.xml中的&lt; url-pattern &gt;标签中，填写的是用户访问servlet的url。一个servlet可以用不同的url。但访问的都是同一个servlet servlet是单例的：在访问一个servlet后，就创建它的对象，保存在内存中 用户每次访问servlet服务器都会为其开一个线程 load-on-startup标签 在web上访问任何资源都是在访问servlet。 缺省servlet。对应缺省的映射路径：&lt; url-pattern&gt;/&lt; /url-pattern&gt;。当访问一个没有映射servlet的资源时，会将其交给使用缺省映射路径的servlet。问题： URL输入http://localhost:8080/thirdSample/index.html 1）到当前thirdSample应用下的web.xml文件查找是否有匹配的url-pattern。 2）如果没有匹配的url-pattern，则交给tomcat的内置的DefaultServlet处理 3）DefaultServlet程序到thirdSample应用的根目录下查找是存在一个名称为index.html的静态文件。 4）如果找到该文件，则读取该文件内容，返回给浏览器。 5）如果找不到该文件，则返回404错误页面。 servletconfig:配置文件中的信息。一个servlet有一个。servlet对象可以使用getServletconfig得到。 servletContext:一个应用中所有servlet共享的域。也有get,set方法 如何读取文件？使用配置文件 request 和 responce HttpRequest, HttpResponce实现了请求和响应类。 编码问题：如何告诉浏览器我们使用什么编码？为reponce在响应头中设置编码格式。 responce.setHeader(“Content-Type”,”text/html;charset=UTF-8”); 同样，在向浏览器传输文件时，文件名使用utf-8编码： URLEncoder.encode(filename,&quot;UTF-8&quot;); 实现自动刷新：网页中所谓的自动跳转，是使用自动刷新实现的 response.setContentType(“text/html;charset=UTF-8”); response.getWriter().write(&quot;3秒后跳转页面.....&quot;); //三秒后跳转到index.jsp页面去，web应用的映射路径我设置成/，url没有写上应用名 response.setHeader(&quot;Refresh&quot;, &quot;3;url=&apos;/index.jsp&apos;&quot;); 重定向跳转：地址栏变化。重定向是发生在浏览器，是新的请求，可以去往任意资源 httpResponce.senRedirect(url);//302状态码码表示临时重定向，即访问这个网页，跳转到另一个网页 refferer 转发：将某个请求转向另一个servlet,地址栏未变化。转发是发生在服务器的，只能去往当前Web应用的资源使用RequestDispatcher大佬的博客1大佬的博客2]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2020%2F04%2F13%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[版本号： 0： 短链接，获取资源后就断开(内部怎么实现的？每次发送和接受报文都要连接和断开？) 1： 保持连接，在一个连接上获取多个web资源 请求报文结构：分为：请求行(方法+资源地址+版本号)消息头(请求头)空行请求数据 响应报文结构：响应状态(状态码分为5类，哪5类？)响应消息头空行响应数据 大佬的博客 防丢失copy.. HTTP协议什么是HTPP协议超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。它是TCP/IP协议的一个应用层协议简单来说，HTTP协议就是客户端和服务器交互的一种通迅的格式。 例子:在浏览器点击一个链接，浏览器就为我打开这个链接的网页。 原理：当在浏览器中点击这个链接的时候，浏览器会向服务器发送一段文本，告诉服务器请求打开的是哪一个网页。服务器收到请求后，就返回一段文本给浏览器，浏览器会将该文本解析，然后显示出来。这段文本就是遵循HTTP协议规范的。 HTTP1.0和HTTP1.1的区别HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源【短连接，获取资源后就断开连接】 HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源【保持连接】 HTTP请求浏览器向服务器请求某个web资源时，称之为浏览器向服务器发送了一个http请求。 一个完整http请求应该包含三个部分： 请求行【描述客户端的请求方式、请求的资源名称，以及使用的HTTP协议版本号】多个消息头【描述客户端请求哪台主机，以及客户端的一些环境信息等】一个空行请求行请求行：GET /java.html HTTP/1.1 请求行中的GET称之为请求方式，请求方式有：POST,GET,HEAD,OPTIONS,DELETE,TRACE,PUT。 常用的有：POST,GET 一般来说，当我们点击超链接，通过地址栏访问都是get请求方式。通过表单提交的数据一般是post方式。 可以简单理解GET方式用来查询数据,POST方式用来提交数据，get的提交速度比post快 GET方式：在URL地址后附带的参数是有限制的，其数据容量通常不能超过1K。 POST方式：可以在请求的实体内容中向服务器发送数据，传送的数据量无限制。 请求头Accept: text/html,image/* 【浏览器告诉服务器，它支持的数据类型】Accept-Charset: ISO-8859-1 【浏览器告诉服务器，它支持哪种字符集】Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的压缩格式】Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】Host: www.it315.org:80【浏览器告诉服务器，它的想访问哪台主机】If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】Referer: http://www.it315.org/index.jsp【浏览器告诉服务器，客户机是从那个页面来的---反盗链】8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】Cookie【浏览器告诉服务器，带来的Cookie是什么】Connection: close/Keep-Alive 【浏览器告诉服务器，请求完后是断开链接还是保持链接】Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】HTTP响应一个HTTP响应代表着服务器向浏览器回送数据 一个完整的HTTP响应应该包含四个部分: 一个状态行【用于描述服务器对请求的处理结果。】多个消息头【用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据】一个空行实体内容【服务器向客户端回送的数据】状态行格式： HTTP版本号 状态码 原因叙述 状态行：HTTP/1.1 200 OK 状态码用于表示服务器对请求的处理结果，它是一个三位的十进制数。响应状态码分为5类 响应头Location: http://www.it315.org/index.jsp 【服务器告诉浏览器要跳转到哪个页面】Server:apache tomcat【服务器告诉浏览器，服务器的型号是什么】Content-Encoding: gzip 【服务器告诉浏览器数据压缩的格式】Content-Length: 80 【服务器告诉浏览器回送数据的长度】Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，回送数据的类型】Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】Refresh: 1;url=http://www.it315.org【服务器告诉浏览器要定时刷新】Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器以下载方式打开数据】Transfer-Encoding: chunked 【服务器告诉浏览器数据以分块方式回送】Set-Cookie:SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要保存Cookie】Expires: -1【服务器告诉浏览器不要设置缓存】Cache-Control: no-cache 【服务器告诉浏览器不要设置缓存】Pragma: no-cache 【服务器告诉浏览器不要设置缓存】Connection: close/Keep-Alive 【服务器告诉浏览器连接方式】Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TomcatLearning]]></title>
    <url>%2F2020%2F04%2F13%2FTomcatLearning%2F</url>
    <content type="text"><![CDATA[设置虚拟站点以分开存储webapp： 在tomcat的配置文件夹的server.xml中找到host标签，添加： &lt; context path=”” docBase=”绝对地址”/&gt; 大佬的博客 怎样在idea中配置tomcat:runedit configruation templates: tomcat :server页面： configrue 配置本地tomcat文件夹位置。注意tomcat10.0会出现找不到libralies的问题。 且对于所有版本，要先访问tomcat文件夹，给它能够被访问的权利deployment页面： 部署本地的项目。application contexts是默认的项目虚拟路径。大佬的博客]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[依赖注入]]></title>
    <url>%2F2020%2F03%2F22%2F%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[就是传入符合一定规范的接口的实例？？ 戏精演绎什么是依赖注入]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[注解]]></title>
    <url>%2F2020%2F03%2F22%2F%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是注解官方解释：Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的。 形象解释：注解好像一个标签。这个标签可以贴在类，方法，甚至一个变量上。贴上了这个标签的类或方法拥有了标签内的属性，如果是一个变量(值类型)，那么它的值是注解中对应参数的值 注解内有什么： 属性。即成员变量。但是没有方法 实现： 反射机制 注解怎么用 定义注解: @interface test{ }注解可以用来修饰注解，这种注解称为元注解。java中有@Retention、@Documented、@Target、@Inherited、@Repeatable 注解也可以被引用 TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);// TestAnnotation是一个注解注解不是代码的一部分！ 大佬的博客更详细]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计网第四章编码]]></title>
    <url>%2F2020%2F03%2F12%2F%E8%AE%A1%E7%BD%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[4.1数字到数字转换：涉及的三种技术：线路编码，块编码，扰动 4.1.1 线路编码： 指数字数据转换为数字信号的过程 特性：r(每个信号元素承载的数据元素的个数(位数))数字速率：N,比特率数据速率：S,波特率， S = c * N / r = B min带宽： B,是波特率影响了带宽而不是比特率基线： 接收方接受信号时，接受信号的功率的运行时平均值。 长的0或1字符串会引起基线偏移，使接收方不能正确的解码直流成分：DC成分。频率很低的部分 4.1.2 线路编码方案： NRZ: 不归零，单极性编码 NRZ - L ： 0，高电平， 1 低电平。 NRZ - I： 有跳变，位值是1，无跳变，位值是0 。 平均信号速率： N/2。 长0或1没有自同步。含DC RZ：1是高电平，0是低电平，1到0的中间电平为0。 平均信号速率：N/2 双相编码：r = 1/2 , S ave = N曼彻斯特：结合RZ, NRZ-L。位中间跳变，0是高，1是低差分曼彻斯特： 结合RZ, NRZ-I。 位中间跳变，在位值开始时，0跳变，1不跳变 双极性编码：AMI: 0，电平为0， 1，电平交替正负。伪三元： 1，电平为0. 0，电平交替正负 多电平方案(即信号元素包含多电平)：mBnT: 前两位表示数据模式，m为模式长度，B表示2进制。n是信号模式的长度(有几个信号？)， T表示一个信号有3个电平4D- PAM5：5个电平：-2，-1,0,1，2， 四路传输 多线路传输：MLT-3是其中的一种，三线路传输10m: 曼彻斯特编码100m: MLT-31000m: 4D-PAM5 4.1.3块编码：把m个bit变成n个作为一个块传输(增加冗余位，m&lt; n)。 即分组，置换，组合。 通常是组合编码后再使用其他的线性传输 4B/5B编码 ：用5位组置换4位组，结合NRZ，解决连续0过多的问题，5位中最多只有3个连续0.(包含不超过一个前导0，两个后缀0) 8B/10B: 高5位用5B/6B,低4位用3B/4B 4.1.4扰动 B8ZS(双极性8零替换)8个0替换成 000VB0VB(v与0之前第一个电平极性相同，B相反，V,B间也会比较极性) HD83: 4个连续0替换为000V或B00V(最后一次替换后到当前替换有几个非0极性，奇数个则当前是000V,否则B00V) 4-2 模拟到数字转换4.2.1脉冲码调制(PCM：把模拟信号转换成数字信号的最通用技术):三步骤：采样，量化，编码成位流 采样：每隔Ts(采样周期)采样，采样速率(周期的导数)至少是信号中所含最高频率的两倍(2 fmax:奈奎斯特速率)。对于低通信号，最高频率是 0 + B 量化：量化等级： L (量化等级说明了每个样本有 log2 L位)量化的dalta: dalta = (max - min)/L，样本值量化时取值取最接近的n * dalta量化误差： 量化值与实际值之差。量化误差对SNRdb的影响 SNRdb = 6.02nb + 1.76 db, nb是量化值的编码位数 L = 2的nb次方 通过采样，量化，得比特率 为 f * log2 L( f表示1s采样几次， log2 L 表示1次采几位)]]></content>
      <categories>
        <category>计网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nio]]></title>
    <url>%2F2020%2F03%2F10%2Fmiannio%2F</url>
    <content type="text"><![CDATA[简介： new io ,新的io api，面向缓冲区而不是面向流 nio使用 channel发送和接受数据 核心组件： channel(管道) , bufffer(就像小火车) , selector. 可以把数据写到channel,buffer中，selector用于选择通道 serverSocketChannel(监听链接请求) 和 socketChannel(Tcp的数据读写) Buffer:属性： capacity(容量，缓冲区大小) limit(限制，缓冲区操作数据大小限制)position(缓冲区正在操作数据的位置) mark()标记当前position，使用reset()返回标记处allocate()获取缓冲区put():写入get(byte数组):读出到byte数组flip():切换到读数据模式rewind():把buffer变成原来未读的样子clear():清空缓冲区，但里面的数据依然存在，只是被遗忘了 channel:read(buffer)将通道数据读到缓冲区中 在Java NIO体系中，SocketChannel是用于TCP网络连接的套接字接口，相当于Java网络编程中的Socket套接字接口。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[http基础知识]]></title>
    <url>%2F2020%2F03%2F10%2Fmianhttp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[服务器，客户端都是一组程序]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[maven初学]]></title>
    <url>%2F2020%2F03%2F09%2Fmaven%E5%88%9D%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[命名规范：groupid: 隶属组织.项目名artifactID: 表示该模块是于该项目的哪个模块，构建名必须是小写字母，没有其他字符]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springbootchapter1简介]]></title>
    <url>%2F2020%2F03%2F09%2Fspringbootchapter1%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[简介：基于spring框架的再封装,spring技术栈的整合 优点：快速创建独立运行的spring项目及主流框架集合使用嵌入式的servlet容器(servlet原理？)starter自动依赖和版本控制大量的自动配置无需配置xml 微服务(一种架构风格)一个应用由一组微小服务构成，每一个服务是一个独立的，可替换的软件单元，它们之间通过http互通]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdbcchapter5DAO]]></title>
    <url>%2F2020%2F03%2F09%2Fjdbcchapter5DAO%2F</url>
    <content type="text"><![CDATA[定义： 一种模式，包括Data Accessor 和 Data Object? 一个完整的DAO模式： 数据库连接类，封装了对数据库的操作 VO类，对应的数据库中的表，每个bean的属性都是其中的元素 DAO接口，定义了数据库操作的接口 DAO实现类，实现DAO接口 DAO工厂类，用于获取DAO实现类的实例]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jdbcchapter4事务]]></title>
    <url>%2F2020%2F03%2F09%2Fjdbcchapter4%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[自动提交的操作：DDL断开数据库连接后]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdbcchapter3jdbccrud操作]]></title>
    <url>%2F2020%2F03%2F04%2Fjdbcchapter3jdbccrud%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[疑问：每次批处理crud都要获取连接和断开？频繁获取连接是否会降低效率 为什么不用statement类：会造成sql语句注入sql语句拼接，麻烦 什么是crud:c: create r: read u: update d: delete 使用preparedStatement类（Statement的子类）： public class LearnCreate { public static void main(String args[]){ LearnCreate learnCreate = new LearnCreate(); learnCreate.connectest(); } //测试插入，不过方法名懒得改了 void connectest(){ try { Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/learnjdbc?user=root&amp;password=&amp;serverTimezone=UTC&quot;; try { //1.连接 Connection connection = DriverManager.getConnection(url); //System.out.print(connection); //2.预编译preparedStatement String sql = &quot;insert into person(id,name)values(?,?)&quot;;//??是占位符 //获得sql的预编译PreparedStatement PreparedStatement preparedStatement = connection.prepareStatement(sql); //3.填充占位符 //parameterindex是索引号，与sql语句中依次填写的顺序一致 preparedStatement.setInt(1,0); preparedStatement.setString(2,&quot;hh&quot;); //通用：setObject //例如封装通用方法时 void update(string sql, Object ... args){ for(int i=0;i &lt; args.length; i++){ preparedStatements.setObject(i+1, args[ i ]); //索引从1开始 } } //4.执行 preparedStatement.execute(); //5.关闭资源 if (preparedStatement!=null){ preparedStatement.close(); } if (connection!=null){ connection.close(); } } catch (SQLException e) { e.printStackTrace(); } } catch (ClassNotFoundException e) { e.printStackTrace(); } } } //测试查询：有返回的结果集，对象名是ResultSet //与前面步骤一致，连接，预编译sql语句，但不使用excecute ResultSet result = preparedStatements.excecuteQuery; 一个表中通用的查询： ResultSet result = preparedStatements.excecuteQuery; //结果集的元数据，包含结果集的列数，列名等信息 ResultSetMetaData metadata = result.get ResultSetMetaData(); int columncount = metadata.getcolumncount(); //next方法，返回布尔值，判断结果集此行是否存在，存在则返回true，指针下移 if(result.next){ //最好使用一个对象来封装对应查询表的属性值 //结果是返回这个对象 Customer cust = new Customer(); for(int i=0;i &lt; columncount;i++){ Object columnvalue = result.getObject(i+1); String columnname = metadata.getColumnname(i+1); //使用列名反射，填充对象中对应的属性值 Field field = Customer.Class.getDeclaredField(columnname); field.setAccessible(true); field.set(cust,columnvalue);//设置值 } return cust; } 不同表中通用的查询： //使用泛型返回 // &lt; T&gt;: 泛型参数申明 &lt; T &gt; T getQuery(Class&lt; T&gt; clazz , String sql , Object … args){ } Blob类型(二进制文件)操作 四种Blob: TinyBlob(255bit) Blob(65k) MediumBlob(16M) LongBlob(4G)//前面写的都是最大容量 存储文件过大会使数据库性能下降 操作Blob //setBlob()插入//读取与保存：采用二进制文件读取与保存的方法Blob blob = resultSet.getBlob(“valuename”);InputStream in = blob.getBinaryStream(); 批量操作：使用Batch //使用前：在url中添加?rewriteBatchedStatements=true //执行完sql语句后再提交而不是自动提交，提高速率 connection.setAutoCommit(false); ps = connection.preparedStatement(sql);//预编译 … ps.setObject(..);//填充 ps.addBatch(); if… ps.excecuteBatch();//执行 ps.clearBatch();//清空 … connection.commit();]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdbcchapter2数据库连接]]></title>
    <url>%2F2020%2F03%2F04%2Fjdbcchapter2%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[优点： 配置文件和代码分开，解耦 打包方便 连接步骤： 通过配置文件获得四个基本量： 用户名，密码，url，驱动名 Inputstream in = MainClassName.getClassLoader.getresource(配置文件url);Properties p = new Properties();p.load(in);String user = p.getProperties(username);…//String url = “jdbc:mysql://localhost:3306/dbname?useSSL=false&amp;//serverTimezone=UTC”; 注册驱动: Class.forname(driver); 连接： Connection conn = DriverManerger.getConnection(url);]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdbcchapter1jdbc概述和程序编写]]></title>
    <url>%2F2020%2F03%2F02%2Fjdbcchapter1jdbc%E6%A6%82%E8%BF%B0%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[什么是jdbc: 一组java的，独立于所有数据库的，用于使用java语言操作数据库的api 程序编写步骤： 导入java.sql包 附加相应数据库厂商的驱动 加载驱动程序 创建connection对象： 连接数据库 创建statement对象： 操作 创建resultset对象： 返回操作结果 关闭statement,connection]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网chapter1绪论]]></title>
    <url>%2F2020%2F02%2F29%2F%E8%AE%A1%E7%BD%91chapter1%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[1.1 数据通信数据通信是,具有4个特点。数据通信系统包括5个部分。数据表示有。数据流有3中方式__。1.2 网络1.2.1 分布式处理1.2.2 网络具有3个准则：性能，可靠性，安全性。性能可以通过吞吐量和延迟来度量。1.2.3 物理结构：包括连接类型和拓扑结构。1.2.4 网络分类与模型 1.3 因特网是一种互联网]]></content>
      <categories>
        <category>计网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter21mysql性能]]></title>
    <url>%2F2020%2F02%2F26%2Fchapter21mysql%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[限制性能的原因： explain： 作用：模拟mysql优化器执行你的sql语句，从而知道性能瓶颈 使用：explain + 执行语句 id:id相同，由上至下执行。id不同，id越大的优先度越高。 seclect type: 查询类别primary: 查询中包含子查询，则在最外层的被标记为primarysubquery: 子查询中的第一个查询DEPENDENT SUBQUERY：子查询中的第一个SELECT，而外面的查询。即子查询依赖于外层查询的结果。UNION: 表示此查询为UNION的第二或后续的查询DEPENDENT UNION: UNION中的第二个或后面的查询语句，位于外面的查询UNION RESULT: UNION的结果 table: 这次查询的数据来自与那一张表 type：显示查询使用了哪一种连接类型性能：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;allall: 全表扫描system：表只有一行记录const: 表示通过索引查询一次就找到了。通常是查询主键或unique的eq_ref：唯一性索引扫描，索引是uniqueref: 非唯一性索引扫描，会返回符合某个条件的所有行range: 某个范围内的查询，一般是使用了between,in,&gt;,&lt;等index: 全索引扫描。什么时候是全索引扫描： 搜索某个带索引的字段值。 possible keys 和keyposiible keys: 返回查询字段上存在的索引(只是返回，这些索引在实际使用中可能并没有使用)key : 返回查询中实际使用的索引。当使用覆盖索引时，possible keys中不显示索引，key返回覆盖索引名(覆盖索引：当查询时只用从索引中得到数据而不需要从数据库中得到，就是覆盖索引) key_len:返回使用的索引的最大可能长度，并非实际使用值 ref:显示哪一列或哪个常量被和索引一块使用来查询 rows： 估计查询得到结果大概需要查询的行数 extra:额外信息using filesort: mysql自行使用了文件排序using temporary: 使用了临时表]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter20mysql索引]]></title>
    <url>%2F2020%2F02%2F26%2Fchapter20mysql%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[索引语法 什么是索引：是帮助mysql高效获得数据的排序的快速查找的数据结构（满足特定算法）。目的在于提高查询效率，可以类比字典(会影响到order by)。索引往往以索引文件的形式存储在磁盘上 优势：提高查询效率，降低排序成本 劣势：索引占用空间，且更新数据还需更新索引 分类：单值索引：一个索引只含单个列，一个表可以含有多个单值索引(一张表最多不要超过5给单值索引)唯一索引：索引列的值必须唯一，但可以为空(什么叫索引列的值，一个值？)复合索引：一个索引包含多个列 什么时候时候建索引： 建立主键自动建立索引 需要频繁查询的字段 建立复合索引而不是单值索引 查询中排序或分组或统计的字段建立索引 查询中与其他表建立关联的字段建立索引 不适合建索引： 重复性高的列 记录太少的表 经常更新的]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter19mysqljoin]]></title>
    <url>%2F2020%2F02%2F26%2Fchapter19mysqljoin%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[chapter18mysql性能下降原因与sql执行加载顺序]]></title>
    <url>%2F2020%2F02%2F26%2Fchapter18mysql%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D%E5%8E%9F%E5%9B%A0%E4%B8%8Esql%E6%89%A7%E8%A1%8C%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[性能下降： 查询语句写的不好 关联表太多 索引问题 服务器调优和各参数设置 加载顺序： from on(连接条件) join where group by having select distinct order by limit]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter17mysql逻辑架构]]></title>
    <url>%2F2020%2F02%2F26%2Fchapter17mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[connector mysql server: connection pool &amp; parser(程序分析) &amp; optimizer(优化器) &amp;cache engine file system(文件i/o)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter16mysql分支结构]]></title>
    <url>%2F2020%2F02%2F24%2Fchapter16mysql%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[分类： case ,if , 循环 case 结构： case when … then 要返回的值 when .. else.. end case; 循环 //跳出： leave 标签名 //进行下一次循环： iterate //while:先执行后判断 a: while 条件 do ... end while a; //a是while的标签名 //repeat:先判断后执行 label: repeat 循环体 until ... end repeat label; //死循环 label: loop 循环体 end loop label;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter15mysql函数]]></title>
    <url>%2F2020%2F02%2F24%2Fchapter15mysql%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数与存储过程的区别：函数有且仅有一个返回，存储过程可以有多个 创建函数 create function name (参数列表) returns 返回值类型 begin .. end]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter14mysql存储过程]]></title>
    <url>%2F2020%2F02%2F24%2Fchapter14mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么是存储过程：一组复杂的mysql语句的封装，可以被外界调用 存储过程的创建: delimiter 结束符号(为了与;区别开) create procedure name(参数列表) begin sql语句 end结束符号 //参数列表： //参数模式 参数名 参数类型 in name type //参数模式: in: 参数可以作为输入 out:参数可以作为返回值 inout:上述结合 存储过程的调用: call(参数列表) 删除： drop procedure name;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter13mysql变量]]></title>
    <url>%2F2020%2F02%2F24%2Fchapter13mysql%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[变量分类：系统变量（全局，会话）,自定义变量（用户变量，局部变量） 系统变量： 查看所有系统变量 show global variables;//查看所有全局变量show session variables;//查看所有会话变量，不写session默认查看会话变量show global|session variables;//查看所有系统变量 查看指定变量 select @@变量名; 修改变量值 set @@变量名 = ; 自定义变量： 用户变量： //作用范围：一个会话//创建并初始化set @变量名 = ；//1select @变量名:= ;//2//查看select @变量名; 局部变量： //作用范围：一个事务。//定义/声明必须在begin,end中的第一句话//初始化：setbegin;declare m int default 1;// declare type default value;set m = …;end;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter12视图]]></title>
    <url>%2F2020%2F02%2F24%2Fchapter12mysql%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[mysql视图的定义： //view,一种虚拟的表，只保存了逻辑语句的空间。封装了各种查询逻辑，方便得到查询结果 create view v as select * from tablename;//创建了一个视图 select * from v;//使用视图 创建视图 create view viewname as 查询语句; 修改视图 //1 create or replace view viewname as 查询语句; //2 alter view viewname as 查询语句; 查看，删除 show.. drop view viewname; 视图内容的修改 insert;//增 delete;//删 update;//改 //对视图的修改会导致其关系到的表的修改，但是有一些视图是不能修改的，比如 //常量视图，使用子查询得到的视图，使用join得到的视图。 //一般不对视图修改]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter11mysql语言分类]]></title>
    <url>%2F2020%2F02%2F19%2Fchapter11mysql%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[SQL（Structure Query Language）结构化查询语言 DQL（data query language）数据查询语言 select操作 DML（data manipulation language）数据操作语言，主要是数据库增删改三种操作 DDL（data defination language）数据库定义语言，主要是建表、删除表、修改表字段等操作 DCL（data control language）数据库控制语言，如commit，revoke之类的，在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组织与体系结构chapter1]]></title>
    <url>%2F2020%2F02%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84chapter1%2F</url>
    <content type="text"><![CDATA[计算机系统组成：软件系统，硬件系统 硬件系统： 早期的冯诺依曼结构：以运算器为中心 冯诺依曼特点： 二进制编写指令。。。 北桥：集成高速接口与内存处理器南桥：集成低速接口]]></content>
      <categories>
        <category>计算机组织与体系结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读书笔记:如何阅读一本书]]></title>
    <url>%2F2020%2F02%2F16%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[##最重要的是，你通过阅读得到的知识，可以转化成怎样的措施和生活建议，可以用来做什么和怎么做。关键时阅读完这本书后，以后你会怎么做 第一章阅读的活力与艺术：内容： 阅读分为为了获得咨询阅读或消遣而阅读，还有为了增进理解而阅读。为了增进理解阅读需要我们去主动阅读，主动阅读需要观察力，记忆，分析，想象。主动阅读时一个主动学习的过程。 阅读的层次 基础阅读：基本的阅读，明白文中的句子在说什么，要求是能认字就行。 检视阅读：在有限时间内，快速了解一本书表象上给你的知识。 分析阅读：深度分析一本书，将一本书变成你自己的。然而要注意的是，有些书值得这么做，有些仅仅值得浅尝辄止。 主题阅读：在一个主题上阅读多本书 检视阅读： 两种检视阅读：有系统的略读或粗读 与 粗浅的阅读 检视阅读的帮助：告诉你一本书值不值得分析阅读。告诉你一本书的大概。 有系统的阅读：第一步，先读书名和序，给这本书分类。第二步，读书的目录，在心里留下一个大概框架。第三步，读一读索引和出版者介绍。完成以上三步，可大概知道是否需要继续往下读。第四步，四处翻一翻，留意书的脉络是怎样递进的，绝对不要错过作者最后的总结 粗浅的阅读：暂时放下不理解的地方。 什么时候使用检视阅读： 想要大概了解一本书，知道其是否值得读时。阅读一本难懂的书时。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter10mysql索引]]></title>
    <url>%2F2020%2F02%2F15%2Fchapter10mysql%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[什么是索引： 创建索引后，拥有索引的字段，mysql会在其内部创建该索引中每一项的“指针”。当搜索某一行 where name = ‘mike’; 若name这一字段创建了索引，则只需要从该列搜索，不需要遍历每一列。增大搜索速度，但增长了更新的时间 设置索引 create index indexname on tablename(fieldname); create table tablename( index[ idnexname ] (fieldname); ) primary key是索引]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter9mysql通配符]]></title>
    <url>%2F2020%2F02%2F15%2Fchapter9mysql%E9%80%9A%E9%85%8D%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[通配符 描述 % 替代 0 个或多个字符 _ 替代一个字符 like ‘_oogle’; [charlist] 字符列中的任何单一字符 [^charlist] 或[!charlist] 不在字符列中的任何单一字符]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter8mysql事务]]></title>
    <url>%2F2020%2F02%2F12%2Fchapter8mysql%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[什么是事务：一个完整的不可拆分的工作流程。每一个语句成功时事务才算成功，有一个失败则失败。分类：显式与隐式 自动提交：mysql中默认隐式事务，即自动提交,即每一句话都看作一个事务，是不能回滚的 roll back;//无效 select @@autocommit;//得到 @@autocommit = 1; set autocommit = 0;//关闭自动提交，显式事务开启 //任何操作后输入commit才真正有效 commit;//这之后roll back无效 使用begin 或 start transaction 手动开启事务。处于begin或。。的后方语句组成一个事务，可以回滚（就算默认事务开启） begin; update….; update….; commit;//提交，事务结束，不可以回滚 事务的四大特征：A： 原子性，事务是最小的单位C： 一致性，要求事务中所有语句成功事务才成功I: 隔离性，事务之间隔离D： 持久性，事务一旦结束就不能回滚 事务的隔离性： read uncommitted(读未提交,副作用：脏读，不可重复读，幻读)a 操作事务，事务未提交，但是b可以看到操作的结果 read committed(读已提交，即不可重复读，幻读) repeatable read(可重复读，mysql默认级别，副作用：幻读)确保事务可以多次从一个字段读取相同的值，当这个事务a在操作时，禁止其他事务对这个字段进行更新 serializable(串行化，无以上三个副作用，当一个事务中对于数据库操作时，这个操作完成了，其他数据库的写操作才会继续进行) 查看隔离性级别： //8.0select @@global.transaction_isolation;//系统级别select @@transaction_isolation;//会话级别//5.xselect @@global.tx_isolation;select @@tx_isolation; 设置隔离级别 set global transcation_isolation level read uncommitted; 副作用脏读：一个事务可以读取其他事务未提交的操作不可重复读：一个事务从开始到提交前，所做任何操作其他事务是无法查看的。而更新某个字段的操作可以查看，即a修改了某个字段，b查看该字段发现该字段与之前不同幻读：事务a读取表中某字段，然后事务b插入了某些行，则a再次读取时发现多了几行 隔离级别越高，性能越差 savepoint; do…; savepoint a; do ….; rollback to a;//回滚到保存点a]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter7mysql连接]]></title>
    <url>%2F2020%2F02%2F12%2Fchapter7mysql%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[内连接： inner join 或join //表示两张表通过一定的条件查询并连接 select * from person join card on person.id = card.id;// on后是条件 左外连接： left outer join 或 left join //表示两张表中左边表都查询得出，右边符合条件才得出，而连接时，右边没有则为null select * from person left join card on person.id = card.id; 右外连接： right join 全外连接： full join //mysql不支持 full join. //full join 表示连接两个表中所有，不符合条件的也都用null补上]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter6子查询]]></title>
    <url>%2F2020%2F02%2F11%2Fchapter6%E5%AD%90%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[查询班级号为 95011的学生成绩的平均分 //score表中没有班级号，从student表中选取学生编号（score表中有学生编 //号） select avg(degree) from score where sno in (select sno from student where class = &apos;95011&apos;) group by cno;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter5多表查询]]></title>
    <url>%2F2020%2F02%2F10%2Fchapter5%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[使用where table1.id = table2.id;并联查询]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter4数据库的设计范式]]></title>
    <url>%2F2020%2F02%2F10%2Fchapter4%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[第一范式：所有字段都是不可拆分的原子值（1NF） 第二范式：在满足第一范式的条件下，除了主键字段以外的字段都必须依赖于主键字段（用拆表实现） 第三范式：在满足第二范式的条件下，除了主键列的其他列之间不能有传递关系]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter3数据库中的约束]]></title>
    <url>%2F2020%2F02%2F10%2Fchapter3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[主键约束：添加上该约束的字段必须在创建记录时时唯一且非空的(非NULL) //添加主键约束 一张表只能有一个主键约束 create table user(id int primarykey) //也可这么写： primary key(id,name) 代表id,name两个的组合时唯一和非空的,其中任一字段不为空，这叫做联合主键 //在建表后添加和删除或修改约束 //添加 alter table tablename add primary key(id); //删除 alter table tablename drop primary key; //修改 alter table tablename change(或者是primary) primary key(id); 自增约束：添加上该约束的字段，在向table中添加记录时，该字段可不用填写，会自动增长 create table user(id int primarykey auto_increment); 唯一约束： unique 非空约束： not null 默认约束：当插入记录时，如果没有填入字段，则使用默认修饰的字段会填入默认值 create table tablename( id int default 10;//默认值为10 ) 外键约束 foreign key(副表中的一个字段) references 主表name (主表中的一个字段) //1.主表中的一个字段的值如果被副表所依赖，该值不能删去 //2.副表中依赖主表某个字段的字段，添加的字段值只能是父表中已经有的值]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter2数据库中常用数据类型]]></title>
    <url>%2F2020%2F02%2F10%2Fchapter2%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数值类型 字符串 日期/时间]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库介绍与分类]]></title>
    <url>%2F2020%2F02%2F09%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[数据库分为两类：关系型与非关系型 关系型：关系型将数据结构归为简单的二元关系（二维表格形式），对数据的操作就是多个表格的分类，合并，连接，选取，例如：mysql,oracle 非关系型分为： 键值存储 列存储 文档存储：数据项的最小单位是文档（例如MongoDB） 图形数据库 搬运大佬的博客]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter14并发]]></title>
    <url>%2F2020%2F02%2F06%2Fchapter14%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[14.1 线程与进程 什么是线程：一个任务就是一个线程。线程之间共享数据。进程是一个程序的实例，进程独享数据，一个进程包含多个线程 线程是计算机中最小的调度单位。一个线程就是一串指令流，进程是计算机中的最小资源分配单位，在计算机中不活动，只作为线程的容器 进程间的通讯:同一台计算机的进程通讯称为Icp,不同的计算机间的进程通讯要通过网络，且要遵守一些协议如Http 14.2 并行与并发 什么是并发(concurrent)：线程轮流使用cpu的做法称为并发。多个线程其实是线性调度cpu的 什么是并行： 多核cpu中的不同核心同时做多个不同线程 14.3 线程应用 同步调用:得到结果后才能向下运行 异步调用：不需要得到结果也能向下运行 14.4 创建线程 Thread t = new Thread(){ public void run(){} } t.setName(“”)；//为线程设一个名字 t.start(); 把线程和线程要执行的任务分开 //runnable传入thread中的作用：赋给一个target变量，其调用run方法 Runnable r =new Runnable(){ public void run(){}//要执行的任务 } Thread t = new Thread(r，”name”);//传入 在方法中使用lambda简化Runnable是一个只有一个抽象方法的接口。在java中，这样的接口叫FuctionnalInterface,只要传入一个lambda表达式就可以生成一个接口对象。 //1 Thread t = new Thread(()-&gt;{ public void run(){} }) //2 Runnable r =()-&gt;{ public void run(){}//要执行的任务 } Thread t = new Thread(r，”name”);//传入 使用FutureTask与Thread配合FutureTask 相当于升级的Runnable,其运行时可以有返回值。而Runnable终的run方法是void(不能使用lambda表达式方法体中返回值？？？) //FutureTask是泛型，需要传入一个callable接口或直接使用lambda表达式 FutureTask ft = new FutrueTask&lt;&gt;(new Callable(){ public Intergeter call(){ return 1; } }) Thread t = new Thread(ft,”t1”); t.start(); int i = ft.get();//get方法得到返回值，但t1线程和总线程有什么关系？？？ //主线程main和t1并行执行，当主线程执行到ft.get()时，其等待t线程的返回 使用jconsole监控本地或远程的进程：一个可以监控java进程的工具,win+r输入jconsole打开 14.5线程运行原理 栈与栈帧：虚拟机内存有堆，栈。栈对应一个线程，每次该线程调用某个方法时，就会为这个方法创建一个栈帧，栈就是由一个个栈帧组成的，栈帧中包含了方法调用时的变量。栈是一个后进先出的数据结构，调用方法结束后，回到调用这个方法的地方，释放该方法所占用的栈帧。栈帧包括局部变量表，返回地址，锁记录，操作数栈//方法调用存在栈里，对象存在堆里 运行时详细：运行一个java程序的过程虚拟机先加载主类，将其中的方法的字节码放到方法区中。在运行main方法的过程中，先加载main方法的栈帧，然后程序计数器逐一运行main方法的每一行代码，当有调用其他方法时，在生成新的栈帧。 14.6常见方法 start和run的区别 //为什么要调用start而不直接调用run? //调用start是启动一个线程（不是立刻启动，而是进入就绪，具体启动实践由任务调度器决定） //start只能调用依次，多次调用抛出IllegalThreadStateException sleep与yield //调用sleep将让线程从Running进入Timed waiting阻塞状态 Thread.sleep(time);//在t1线程中调用Thread.sleep()让t1进入等待 t1.interupt();//打断t1的睡眠，将其唤醒,将抛出InteruptedExcption //睡眠结束后的线程不会立刻得到执行 //调用yield让线程从Running进入Runnable(就绪)状态 //yield与sleep的区别：yield方法无参数，其是将时间片的使用权让给其他线程，可能出现无其他线程而调用yield方法的线程继续运行的 //状况，而sleep是让线程必须休眠多少时间 Thread.yield(); 设置线程优先级：优先级高的线程将获得更多的时间片，执行时间会更长。但当cpu是空闲时，优先级是没什么用的（什么叫空闲？？） t1.setPriority(1);//优先级为1 join方法：让某个线程在主线程中调用join，即让该线程执行完毕后主线程才继续向下运行 System.out.println(“t1 join”); t1.join();//t1.join(time) 表示最大等待t1结束的时间 System.out.println(“t1 join end”); interupt用法：打断线程。可以打断正常运行的线程（使这个正在运行的线程的打断标记值为true,但这个线程不会停止，应根据打断标记自行决定），也可以打断休眠或waiting的线程（唤醒，标记值仍为false,想要停止，就自行在捕捉异常中再打断一次） //优雅的停止线程 //使用interupt 两阶段停止 14.7 守护线程在jvm中刚启动时，除了主线程，其他都是守护线程。主线程中创建的线程默认是普通线程。守护线程与普通线程的区别在于，主线程结束后，若为普通线程，则程序在普通线程结束后结束，若为守护线程，则守护线程无论是否允许完毕都结束。 //可以使用setDeamon(true)将线程设置为守护线程]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter13部署java应用程序]]></title>
    <url>%2F2020%2F02%2F05%2Fchapter13%E9%83%A8%E7%BD%B2java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[13.1jar文件 jar文件是java类与其他文件的打包集合（图片，清单文件等。清单文件是描述jar文件归档特征的文件）。以压缩包为结构，jar为后缀名。可以用压缩包压缩，也可以用jdk自带的jar制作 2 应用首选项的存储： 怎样存储应用文件的配置信息？可以使用Propertries类。其实现了Map接口，用字符串映射的方式存储配置，常用方法如下： Propertries p = new Propertries(); p.setPropertries(“title”,””); p.stored(out,”注释”);//out是输出流。这个是将配置存储的操作 p.load(in,”注释”);//读取配置]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter9集合]]></title>
    <url>%2F2020%2F02%2F04%2Fchapter9%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[9.1java集合框架 集合的接口与实现分离:l两个基本接口collection与map collection接口 迭代器：迭代器能修改集合包括方法：next(); hasNext();remove();//删除上次调用next()得到的元素。必须调用了next()才能调用remove();add();//链表的add通常在表尾添加，迭代器的add在当前遍历到的位置上添加（即使用上一次使用next()得到的位置） //删除相邻元素Iterator iter = capicity.Iterator();iter.next();iter.remove();iter.next();iter.remove(); forEachRemaining();//参数为lambda表达式，调用这个方法的迭代器中的每个元素都会调用这个表达式 实现了迭代器接口的集合都可以使用for:each循环 9.2具体的集合： 链表：LinkedList类，对于迭代器listInterator。实现了双向链表 数组列表：ArrayList, 非线程安全。vector是线程安全的 散列集：HashSet. 树集：treeSet序的集合 9.3映射： Map分为HashMap和TreeMap(排序，实现了SortedMap接口，具有方法firstKey与lastKey分布返回最大键值与最小键值)//getOrdefault方法//map.getOrdefault(key,defaultvalue)//查找map中对应key的value,若key不存在，返回defayultvalue(参数)，通常用于频度 基本操作：put(key);//插入get(key);//获取，若key不存在返回null 映射视图：返回的映射的视图可以删除里面的元素，对应原映射中的元素会被删除。但不能往映射视图里添加元素 keyset();//返回key的集合values();//返回value的集合entryset();//返回键值对集合 废弃的键值删除一个键值在最后一次被调用后，垃圾回收器不会自动删除它。因此处理这些废弃项很重要弱散列？？？ 9.4视图 视图：可以对映射操作的，实现了set接口的集合 同步视图：对于要求的线程安全，不对集合实现线程安全的类，而是实现线程安全的视图]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter8泛型程序设计]]></title>
    <url>%2F2020%2F01%2F31%2Fchapter8%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[写在前面：类型参数 ：T参数类型 ：T的类型类型变量 ：T value; value就是泛型变量参数化类型变量：使用泛型的变量8.2定义简单泛型类 class Pair&lt;T,E&gt;{ T value ..... //T称为类型参数 E value2 ..... }8.3泛型方法： 泛型方法可以定义在普通类和泛型类中： class Normal{ void test &lt;T&gt;(T value){ } } //在调用test时，可以加上尖括号T，也可不加。编译器会自动通过圆括号内参数类型判断8.4类型变量的限定： //通过extends继承限制 void test&lt;T extends Comparable&gt;(T ...) //这样test方法的参数都必须是Comparable的子类，意味都实现了CompareAble void tete &lt;T extends Comparable &amp; Serieable&gt;(T...) //指泛型同时满足这两个类型8.5泛型代码和虚拟机？？ 类型擦除： 在java的编译器中没有泛型。只有普通的类和方法。泛型在编译期间会被擦除掉相关信息，被替换成原始类型，即参数为Object或Object的子类（看extends的限制） class Test&lt; T extends String &gt;{} //编译器中的限定类型为String 翻译泛型表达式： 泛型先翻译为原始类型（限定类型），然后强制转换 翻译泛型方法？ 8.6约束与局限性： 不能用基本类型实例化类型参数,应用对应包装器类型 不能使用instanceof 查询某个变量是否属于某个泛型类，不能强制转换。使用getClass得到一个泛型类的类型，例如 Pair&lt; String &gt;p;p.getClass()返回的都是 Pair&amp;ltT&amp;gt 不能创建参数化类型的数组 （为什么我也不清楚，因为类型擦除导致的不安全？什么是参数化类型：被参数化的类型，例如8.2中的value），要收集参数类型应该使用List Pair&lt; String &gt;[] table = Pair&lt; String &gt;[10];//Error 不能实例化类型变量： 什么是类型变量 (就是T) ？ T test = new T();//Error 不能实例化泛型数组 静态方法可以使用泛型，但不能是构建类的泛型class Pair&lt; T &gt;{ static void &lt; T &gt;Pair &lt; T &gt;test(){}//这里的Pair不是构建得到的Pair} 8.7通配符： 子类型通配符： pair&lt;? extends …&gt; //只能进行读操作，不能写pair&lt;? super …&gt; //只能写，不能读]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter7异常，断言和日志]]></title>
    <url>%2F2020%2F01%2F30%2Fchapter7%E5%BC%82%E5%B8%B8%EF%BC%8C%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[7.1异常：一.异常分类： 异常都是Throwable的子类，分为： Error:资源耗尽或内部错误 Exception: I/O Exception Runtime Exception : 包括访问空指针，数组越界，错误的类型转换。都是程序编写者自己的错误Error和Runtime Exception称为非受查异常，其他未受查异常 二.声明受查异常： 通常在可能抛出受查异常的方法使用throws声明可能抛出的异常（不是方法一定抛出异常） public FileInputStream(String name) throws FileNotFoundException{ if(){ throw new ...Exception();//抛出异常。一旦一个方法抛出异常，则这个方法不会返回到调用者 } } 如果子类覆盖了超类的方法，则这个子类方法抛出的异常不能比父类的更通用。若父类方法不抛出异常，则该子类方法也不能抛出异常 三.创建异常类： 创建的异常必须继承于已有的异常，习惯上包括两个构造器。一个是默认的无参数构造器，另一个是含有String参数的构建包含异常详细信息的异常的构造器： class FileFormatException extends IOException{ public FileFormatException(){ } public FileFormatException(String message){ } }四.捕获异常： try,catch,finally语句。可以用多个catch捕获多种异常]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter6接口，lambda表达式与内部类]]></title>
    <url>%2F2020%2F01%2F28%2Fchapter6%E6%8E%A5%E5%8F%A3%EF%BC%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[6.1接口一.接口是对于类的表现形式。接口可以多implement接口默认为public,其中的方法默认为public,含有的常量默认为public static final ,不含有实例域与静态方法。其中的方法称为抽象方法。但在java 8 中，可以在接口中添加默认方法（也叫扩展方法,必须用default修饰），其是在接口中可实现的，也可为静态的 interface Test(){ default static void test(){ ... } }二.接口的特性：接口不是类，不能直接new,但可以声明接口的变量，这个变量可以指向类的实例 Test t = new Employee();可以用instanceof 判断某个对象是否实现了某个接口，也可以用来判断某个对象是否属于某个类（具有继承关系的也属于，子类属于父类，父类不属于子类） 6.3lambda表达式一.lambda表达式是什么： 一个可传递的代码块，可以看作函数，通常是用于延长执行的代码块二.lambda表达式的编写： 包括参数，代码块，自由变量 (event) -&gt;{ do... }三.注意： lambda表达式只能处理不变的变量，如以下是不合法的 for(i=0;i&lt;10;i++){ ActionListenner litener = event-&gt;{ System.out.print(i);//i改变了，这样的操作不合法 } }四.lambda表达式用来做什么： 用于转换为函数式接口。一些接口只有一个方法，这个方法是未实现的，传入一个lambda表达式则可以生成这样一个接口变量。如上面的ActionListener就是一个接口。这个接口可以传到其他地方生成对象，例如计时器等等 6.4内部类一.私有的内部类： 在调用方法时可以在外部类内创建；二.非私有的内部类： 可以在外部类的作用域外创建 Outer outer = new Outer(); Outer.inner inner = outer.new Inner();三.注意： 内部类不含有静态方法，所有静态量必须是final的（因为不同的外部类可能会有不同的内部类，对于static，我们希望它是内部类唯一的，设置为final使它不能被修改）四.匿名内部类 举例：监听器指向一个匿名内部类： ActionListenner listenner = new ActionListenner(){ Method and par... }具体实现规则： Supertype s = new Supertype(....超的构造参数){ //匿名内部类由于没有名字，不能实现构造器 //其中的方法，域是对Supertype的扩展 //Supertype可以是接口，也可以是一个类 } 举例：在某些方法需要一个对象时，也可以向这个方法传递一个匿名对象 五.静态内部类： 只有内部类可以定义为静态的 静态内部类不能对外围类有引用，因此可以定义为静态的 静态内部类可以有静态方法和静态类，非静态的内部类不可以有 静态方法返回的对象必须是静态类的对象]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter5继承]]></title>
    <url>%2F2020%2F01%2F27%2Fchapter5%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[5.1一.超类和子类： 超类就是父类，也叫基类二.继承了什么： 子类继承了父类的非private的域和非private的方法，但父类的私有域是不能直接访问的，需要通过父类的域访问方法得到 子类不继承父类的构造器 //Manager类继承了Employee public int getSalary(){ int salary = super.getSalary()+bonus;//使用super调用超类 return salary; }三.子类构造器： 在子类构造中，若没有显式的调用父类的构造器，则默认调用父类的默认构造器（无参数）。若父类没有这样的构造器，则会报错 Manager(....,int bonus){ super(....); this.bonus = bonus; }四.多态： 指一个对象变量可以指向超类，也可以指向子类，这叫多态。 根据对象变量实际指向的类型调用方法，这叫动态绑定。 超类的引用可以指向子类，但子类的引用不能指向父类五.final类和方法： 用final修饰的类不能被继承，用final修饰的方法子类不能够覆盖六.强制类型转换： 一个超类的引用指向子类的对象（称为子类向上转型），可以将这个引用转为子类的引用七.父类引用指向子类对象，可以调用子类对象的方法吗？ 除了构造方法，其他都不能。其既不能访问子类对象的特有域，也不能使用子类的方法，除非进行强制类型转换八.protected:同一个包内，子类能够访问 5.2 Object:所有类的超类一.equals方法： 在Object类中，equals方法默认是比较两者的引用，若引用相等则返回true. 在实际应用中，仅仅比较引用是没有意义的。修改的equals方法应该先比较引用是否指向相同的对象，然后比较引用所指向的对象是否为空，再比较两者对象是否同属一个class,最后依次比较两者中各项。 子类的equals方法应该先调用父类的equals方法 //显式参数是object类，比较使用object的equals boolean equals(Object other){ if(this == other){ return true; } if(other == null){ return false; } if(getClass()!=other.getClass()){ return false; } Employee otherobject = (Employee)other; return Object.equals(this.name,otherobject.name)&amp;&amp;this.salary==otherobject.salary; }二.toString方法： 返回对象的字符串表示。通常java的默认类都实现了这个方法。在如 String str = &quot;&quot; + Employee; //默认调用了Employee的toString方法 //在print的时候也是 java中数组的字符串表示用Array.toString(arrayname) 或Array.deepToString(arrayname)得到 5.7.反射：一.Class类： java为每个实例所对应的类型都生成了一个标识Class类。 一个class对象表示一种类型，不一定是类。 Emplyoee e = new Manager();// System.out.print(e.getClass.getName);//返回 Manager]]></content>
  </entry>
  <entry>
    <title><![CDATA[chapter4对象与类]]></title>
    <url>%2F2020%2F01%2F27%2Fchapter4%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一. 类：构造对象的模板，构造对象称为类的实例化二. 封装：数据隐藏，关键在于类中的方法不能直接访问其他类的实例域三. 用户自定义类： 构造器：每个类可有1个或多个构造器，构造器无返回值 封装：关键在于数据域设为private,访问和修改数据域的方法另设，且不返回引用对象而返回对象的clone final修饰对于数值来说，数值不可再修改。对于一个引用，它不会再指向其他对象，但其指向的对象仍然可以修改 static:静态域：用static修饰的域为类所拥有，例： Math.PI静态方法： 用于不能向对象实施操作的方法，这种方法只能访问静态域工厂方法： 返回一个类的实例的静态方法 方法参数：对于java,参数的调用是值调用，若调用的是引用，则在方法中初始化得到的参数是参数的拷贝值，拷贝值与引用参数指向同一个对象，但交换拷贝值不能达成交换参数所指向的对象的目的 对象构造：重载： 方法名相同，参数不同（方法名，参数称为方法签名）。重载后的方法可以返回不同类型返回值显式域初始化： 在构造前，为所有域赋初值是一种很好的习惯调用另一个构造器： Test(String s){this(1,s);//用this（）调用另一个构造器 } 初始化的顺序： 在类第一次被调用时，静态域被初始化。类在被初始化的时候，先将所有域初始化为默认值，然后按声明顺序初始化各域，接着执行构造器]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter3命令行参数]]></title>
    <url>%2F2020%2F01%2F27%2Fchapter3%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[java Testclass -h world表示在main方法中args[] 数组中，args[0] = -h, 1 = world]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter3拷贝]]></title>
    <url>%2F2020%2F01%2F26%2Fchapter3%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[拷贝有深拷贝与浅拷贝，浅拷贝仅仅拷贝值（对于值类型）和内存地址（对于引用型），深拷贝拷贝所有的成员变量浅拷贝： 使用=复制，arraycopy深拷贝：改写后的clone class Dog implements Cloneable{ String name; protected Object clone(){ Dog dog =null; try { dog = (Dog)super.clone(); }catch (Exception e){ } return dog; } } class Test2 implements Cloneable{ int x; private Dog dog = new Dog(); void setDog(String name){ this.dog.name = name; } String getname(){ return dog.name; } Test2(int x){ this.x = x; } protected Object clone() { Test2 t = null; try { t = (Test2) super.clone(); t.dog = (Dog) dog.clone(); } catch (Exception e) { } return t; } }public class TestCopy { public static void main(String args[]){ TestCopy testCopy = new TestCopy(); //使用=是对于对象的浅拷贝，仅仅复制了对象的内存地址 Test2 t1 = new Test2(1); Test2 t2 ; t2 = t1; t2.x = 2; //System.out.printf(&quot;%d %d&quot;,t1.x,t2.x); //修改clone方法后实现深拷贝（直接使用未修改的clone,即没有 t.dog = (Dog) dog.clone();） //（也是浅拷贝，因为直接使用clone只是复制了对象的成员变量的内存地址） Test2 t3 = new Test2(3); t3.setDog(&quot;3&quot;); Test2 t4 = (Test2) t3.clone(); t4.x = 4; t4.setDog(&quot;4&quot;); System.out.printf(&quot;t3 x: %d dogname %s,t4 x: %d dogname %s&quot;,t3.x,t3.getname(),t4.x,t4.getname()); } }]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter1在终端中操作Mysql]]></title>
    <url>%2F2020%2F01%2F26%2Fchapter1%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%B8%AD%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[如何查找每一个科目最高分的学生姓名?如何查找每一个学生的sno,cno,grade列？ add : 添加表中的字段 insert: 添加表中内容drop: 删除表或删除数据库 delete: 删除某一行change: 修改字段形式 update: 更新某一行内容 登录数据库服务器： mysql -uroot-p 显示所有数据库中的库： show databases; 选择数据库： use databasename; 查询当前所在表中的数据： select * from excelname; select name , id from tablename; select distinct fieldname from tablename;//查询表中所有不重复的某字段 select * from score where degree between 60 and 80;//60到80的闭区间 select * from score where degree in (85,86,87);//degree为85或86或87的记录 select * from score order by value1 asc;,value2 desc//升序查询，降序是desc,查询按照value1升序，value2降序（优先：value1） 显示当前库中所有表： show tables; 创建表： create table tablename(各字段 check(条件)//创建表的约束 ); //记录是表中的一行，字段是组成记录的元素 删除表： drop table tablename; 查看某个表： describe tablename; select function();//mysql中可以使用select查询字段，函数，表达式（计算表达式），常量 向表中插入字段： //第一种，支持插入多个字段,支持子查询 insert into tablename values(value1), (value2); //第二种，不支持同时插入多个字段，不支持子查询 insert into tablename set 字段1=…,字段2=.. 删除字段：delete from tablename where …;//可以roll back,假如删除了自增长的字段，字段添加时从断电开始truncate table tablename;//清空表，不能带where,且不能roll back，假如删除了自增长的字段，字段从头开始 更新字段:update tablename set field1=,filed2= … where ….;//修改单表中符合条件的某一行中的某个字段值 向表结构中添加多个字段：alter table tablename add fieldname fieldtype… or and not 统计：countselect count(*) from tablename where…..;//统计 最大值：maxselect id from tablename where(degree = select max(degree) from tablename); limit 0,1:表示从第0个数字开始查，最多查1个 avg();//平均值 group by field;//分组 where 与 having的区别where用于聚合前查询的条件，having 用于聚合后，having后的条件可以使用聚合函数select id from score group by lessonname having count(num)&gt;2; 模糊查询：like(); not like(); like ‘k%’;//查询以k开头的字符串like ‘%oo%’;//查询包含oo的字符串 union :将多个select查询结果放到一个集合中，默认删去重复的，若为 union all则包含重复值 any(): 任意一个 all(): 所有 使用as取别名 select sname, ssex,sbirthday from student union select tname, tsex,tbirthday from teacher;//得到表的字段名为sname, ssex,sbirthday//使用asselect sname as name, ssex as name,sbirthday as name from student union select tname, tsex,tbirthday from teacher; 复制表数据做条件查询 select * from score a where degree &lt; (select avg(degree) from score b where a.cno = b. cno); 将某个表中的数据复制到另一个表 insert into table1 (fieldname1,….) select field1,… from table2; 拼接字符串： select concat(lastname,firstname) as 姓名 from … 不等于： &lt;&gt; 安全等于 &lt;=&gt; , 可以判断NULL值 substr(str,pos);//截取字符串，字符串位置pos从1 开始instr(str1,str2);//返回str2在str1中的起始索引位置，找不到则返回0trim(‘str’from ‘str2’);//从str2中去除前后的str1lapd();//左填充replace()’ 数学函数 round();//四舍五入ceil();//向上取整floor();//向下取整truncate(number,位数);//截断保留几位mod();//取余 时间函数 now();//现在的日期+时间curdate();//现在的日期curtime();//现在的时间 if select if(10&gt;5,’大’,’小’);//第一个条件满足，返回第一个值，否则第二个 case: case 要判断的值when 值 = ? then 要显示的值或语句;// casewhen 条件 then ……; 单行函数：将一个数据进行处理，返回一个值分组函数：将虚拟表看做一个组，处理一组数据，返回一个值 分组查询：分组前查询：查询原始表中有的数据，条件使用where分组后查询：查询原始表中没有的数据，条件使用having exists();//返回是否存在 分页查询：select .. from … limit start,调数; 联合查询：union]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chapter3大实数]]></title>
    <url>%2F2020%2F01%2F26%2Fchapter3%E5%A4%A7%E5%AE%9E%E6%95%B0%2F</url>
    <content type="text"><![CDATA[BigInteger integer = BigInteger.valueOf(1);//创造一个数值等于1的整型大实数 add,substract,devide,multiply(BigInteger) //BigDecimal]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[chapter3输入与输出]]></title>
    <url>%2F2020%2F01%2F26%2Fchapter3%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[一.输入输入使用Scanner或Console类，两者均在java.util包中，其中Console类可以用来输入密码（对于Scanner类输入有显回的原因）,使用： import java.util.* Scanner scan = new Scanner(Sysytem.in);//与标准输入流绑定 String word = scan.next;//读一个单词，以空白符分隔符 String line = scan.nextLine;//以换行为分隔符 while(scan.hasNext())…. //还有nextInt,nextDouble等方法 Console console = System.console; char a[] = console.readPassword();二.格式化 String str = String.format(“hello,%s”,test); System.out.print(“1$f”,new Date());//将Date()中第一个参数以浮点数形式输出]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[看这里！]]></title>
    <url>%2F2020%2F01%2F25%2F%E7%9C%8B%E8%BF%99%E9%87%8C%EF%BC%81%2F</url>
    <content type="text"><![CDATA[祝张慧小朋友新年快乐，希望她永远聪明可爱，温柔大方，健健康康]]></content>
  </entry>
  <entry>
    <title><![CDATA[程序员岗位及详解]]></title>
    <url>%2F2020%2F01%2F23%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B2%97%E4%BD%8D%E5%8F%8A%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前端 后端 全栈 运维 测试 大数据 游戏 研究我的想法： 后端到大数据 （我是全菜工程师！！！！） 一.来自codesheep对于前后端的讲解：1.前后端趋同，都在向工程化走2.前后端需求岗位量都差不多3.前端入门快，但和后端一样，都逐渐复杂4.自学后端容易因为业务量不足（访问流量不足）遇到技术无法提高的瓶颈]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>岗位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learnjs]]></title>
    <url>%2F2019%2F10%2F26%2Flearnjs%2F</url>
    <content type="text"><![CDATA[写在前头： js的作用：验证输入，改变样式，图像（需要给定id来找到元素），触发事件 js的来源：body,head中的中，如果从外部引用则 js显示数据： 弹出警告框： windows.alert() 修改html元素 ： document.getElementById(“ID”).innerHTML=””写到页面： document.write 基本： 定义变量 var …. 定义数组 var a = new Array() js中所有事物都是对象 全局变量是windows对象 html绑定的事件： onclick 点击 onmouseover 在元素上移动鼠标 onmouseout 移开鼠标 onload 加载 undefined 和 null 的区别： undefined类型是undefined，表示一个变量未赋值 null类型是object,表示该变量现在指向一个空值，可以用赋值null来释放内存 js数据类型在： JavaScript 中有 5 种不同的数据类型： string number boolean object function 3 种对象类型： Object Date Array 2 个不包含任何值的数据类型： null undefined]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使图片居中]]></title>
    <url>%2F2019%2F10%2F16%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[设置 且Center中要设置width,否则无效 设置]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css学习]]></title>
    <url>%2F2019%2F10%2F15%2Fcss%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[div标签控制其他元素位置1. //创建//css的三种方法：外部&lt;内部&lt;内联（慎用内联）. css 选择器 ： id,class3. css 控制背景：1.背景图片：平铺：repete 来充满避免背景图片没有容器大size 控制大小attachment: 控制是否滑动，fixed不滑动4.css控制链接格式a:link(未点击) visited(点击后) hover(鼠标移动到链接上) active(点击时)5. css盒子模型：盒子总宽度：（border:边框+padding:内边距+width:内容宽度) 当我们设置一个块时，还要考虑外边距(margin)，即块与浏览器的距离。所有的html标签可以看做盒子6. css嵌套： p{} (所有p标签) .t{}(所有class为t) .t p{} (所有class为t的元素内的p元素) p.t{} (所有class为t的p元素)7. css 显示1.隐藏的方法： p.hidden(visibilty: hidde):隐藏但仍占有空间，p.hidden(display:none):隐藏，不占空间2.display:block,in-line8. css 定位： 使用position, z-index决定了显示的前后位置9. css float : 控制元素当窗口大小不够时的浮动方向]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2F2019%2F09%2F16%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1. 全局配置文件：app.json1. pages：用于添加页面2. tabBars:添加底部按钮2. 页面配置：page.json3. 前端开发要阅读文档即可4. 前端：wx:keywx:for={}绑定一个数组 wx:for-item绑定当前数组的一个变量名每个页面有id,就是加载时的options中]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css]]></title>
    <url>%2F2019%2F09%2F08%2Fcss%2F</url>
    <content type="text"><![CDATA[概念：css，即层叠样式表，是一种语言，可用来设定html中标签的各式 css的引用： 内嵌样式表：style = 文档内嵌入：在&lt;\head&gt;标签内设定&lt;\style&gt;标签，还可以使用类型选择器 外部文档调用：在&lt;\head&gt;标签中链接 层叠：满足某种规则的css，可以使修饰层叠，即多种修饰中，对某个元素只选择一种。有三个因素需要考虑，根据重要性排序如下，前面的更重要：重要程度优先级(id&gt;class)资源顺序(后面的覆盖前面的) 继承。子元素继承父元素的修饰 选择器 盒子模型：displaydisplay:inline , display:block表示该模型对外界元素的排布display: flow layout,grid,flex表示该模型对内部子元素的排布注意：设置未grid布局后，其中子元素的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。 一个被定义成块级的（block）盒子会表现出以下行为:盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽每个盒子都会换行width 和 height 属性可以发挥作用内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”除非特殊指定，诸如标题(&lt; h1&gt;等)和段落(&lt; p&gt;)默认情况下都是块级的盒子。 如果一个盒子对外显示为 inline，那么他的行为如下:盒子不会产生换行。 width 和 height 属性将不起作用。垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。水平方向的内边距、外边距以及边框会被应用而且也会把其他处于 inline 状态的盒子推开。用做链接的 &lt; a&gt; 元素、 &lt; span&gt;、 &lt; em&gt; 以及 &lt; strong&gt; 都是默认处于 inline 状态的。 总结：block换行，高度起作用，垂直方向上边距起作用。inline不换行，高度，垂直方向上边距不起作用]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web 的基础知识]]></title>
    <url>%2F2019%2F09%2F03%2Fweb-%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1. web:1. web资源：动态（程序生成数据，有交互功能），静态（数据不变）2. web应用：多个web资源放到同一个目录，要想供外界使用，就放到web服务器上]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[静态链表]]></title>
    <url>%2F2019%2F09%2F02%2F%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[概念 ： c语言中，使用数组结构的，结合顺序和非顺序特点的数据结构 逻辑结构 ： 先初始化一个超大数组（结构体的数组，结构体包括两个变量：data ,cur(指向下一个节点的数组序号)，0号节点是备用链表的头 创建：创建这个数组，然后每个节点的默认data是-1，cur是i+1（最后一个节点的cur是0） 初始化（其实应该是从备用列表中，取一个新节点到可用链表中（可用链表和备用链表在一个数组中），除了0号节点）： int mallocarr(*arr){ int i = arr[0];//此时0号节点指向的是备用节点的第一位 if(arr[0]){ arr[0].cur = arr[i].cur } return i; }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python IO]]></title>
    <url>%2F2019%2F09%2F01%2Fpython-IO%2F</url>
    <content type="text"><![CDATA[打开文件： #读取 f = open(url,’r’) #写入（覆盖） f = open(url.’w’) ##这样就是创建新文件 #追加 f = open(url,’a’) 一次性读：read 创建新的文件目录： import os os.mkdirs(ur)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python错误及调试]]></title>
    <url>%2F2019%2F09%2F01%2Fpython%E9%94%99%E8%AF%AF%E5%8F%8A%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[格式： try: except errorname as e finally: 抛出错误： raise error]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python类与实例]]></title>
    <url>%2F2019%2F09%2F01%2Fpython%E7%B1%BB%E4%B8%8E%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[创建一个类 class name(): # (继承对象，可以多继承) 必须有 def /init__(self): 要限制外界访问类的某个变量，可以使变量名开头为双下划线__ 可以直接为实例对象添加属性和方法： s = name() s.score = 90 也可以直接为类添加属性和方法，但可以使用slots来限定实例对象能添加的属性名字 class name(): def __init__(): __slots__ = (&quot;name&quot;) #绑定的变量名只能是name 获取对象的所有属性和方法： dir() 防止外界直接查看或修改实例的属性： 构造get,set方法，还可以用@propetry修饰它们，使这些方法可以像属性一样调用，前提是方法名一致 class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError(&apos;score must be an integer!&apos;) if value &lt; 0 or value &gt; 100: raise ValueError(&apos;score must between 0 ~ 100!&apos;) self._score = value]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python生成器]]></title>
    <url>%2F2019%2F08%2F31%2Fpython%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[what is generator???一种惰性的计算机制，只有调用next（generator)时才会计算调用其中元素定义一个生成器： (x for x in range(0,11)) def name(): for i in range(0,11):yield i使用生成器：a = name()next(a) ## 调用其中一个元素，从投至尾]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python is and ==]]></title>
    <url>%2F2019%2F08%2F31%2Fpython-is-and%2F</url>
    <content type="text"><![CDATA[is : 比较引用地址是否相同== ： 比较对象内容是否相同]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2F2019%2F08%2F31%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.定义函数: def name(): pass这是定义了一个空函数2.函数只有一个函数，但可以用一个元组返回多个值 def name(): … return x,y x,y = name()3.参数检查： def name(x) if not (isinstanceof(x,int)): raise TypeError(“bad type”)4.默认参数 def name(x,y=1)5.可变参数 def name(x,y): for k in y: print(y) #y是一个元组 name(x,y) y是一个元组，将y解析成一个个参数 6.关键字参数 def name(x,**y): pass name(x,gentle = “a”)##传入一个键值对]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[collection与collections]]></title>
    <url>%2F2019%2F08%2F31%2Fcollection%E4%B8%8Ecollections%2F</url>
    <content type="text"><![CDATA[collection : java.util下的一个接口collections : java.util下的一个集合类]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python正则表达式]]></title>
    <url>%2F2019%2F08%2F30%2Fpython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式： 用于检查符合某种模式的字符串匹配 python中使用re模块]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表 元组 字典 集合]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%88%97%E8%A1%A8-%E5%85%83%E7%BB%84-%E5%AD%97%E5%85%B8-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[列表1.创建列表： 1.a = [] 2.列表解析式 a = [value for value in range(1,11)] 3.a = list(range(1,11)) 4.使用切片复制 a = b[:]2.对列表操作：添加add 插入insert 删除remove 弹出pop 连接 extend(another list) 排序sort() 得到排序而不是对列表对象直接操作sorted() 反转reverse() 元组 创建元组： () 元组不可修改 字典 创建 ：a ={} 添加键值对 :a[key] = value 删除 : del a[key] 返回键值.keys() 返回值.values() 返回字典中的一个键和值.items() 集合不能使用索引，分片，因为其是无序的]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python输入输出]]></title>
    <url>%2F2019%2F08%2F29%2Fpython%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[1.打印： py2: print”” py3:print(“”) [去掉空格：print(“”,end=””) 打印格式化： b = “1{}2{}3{}” print(b.format(1,2,3))]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python String]]></title>
    <url>%2F2019%2F08%2F29%2Fpython-String%2F</url>
    <content type="text"><![CDATA[1.删除字符串中空白：头：lstrip() 尾： rstrip() 两端: strip()]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python爬虫]]></title>
    <url>%2F2019%2F08%2F28%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[爬虫的定义1.一段程序 2. 模范浏览器浏览网页 3. 自动搜集数据步骤：1.调用模块，爬取网页文件（html)2.使用正则表达式处理文件3.存储数据]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[StringBuilder和StringBuffer]]></title>
    <url>%2F2019%2F08%2F28%2FStringBuilder%E5%92%8CStringBuffer%2F</url>
    <content type="text"><![CDATA[1.StringBuilder速度更快，但不支持线程安全2.两者都支持原地修改字符串，而不是生成新的对象 public static void main(String args[]){ StringBuilder test = new StringBuilder(&quot;123&quot;); test.append(&quot;a&quot;); test.append(4); System.out.println(test); test.delete(1,2);//不包括end System.out.println(test); System.out.println(test.subSequence(0,1));//不包括end test.setLength(2);//从前到后截断 System.out.println(test); System.out.println(test.lastIndexOf(&quot;1234&quot;)); }]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[System类的一些方法]]></title>
    <url>%2F2019%2F08%2F28%2FSystem%E7%B1%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[public static void main(String args[]){ //列出系统的所有属性，getPropertries()返回propertries类 //System.getProperties().list(System.out); //用毫秒为单位得到返回类型为long的当前时间 //System.out.println(System.currentTimeMillis()); int[] test1 = new int[10]; for (int i =0;i&lt;10;i++){ test1[i] = i; } //数组的复制 System.arraycopy(test1,0,test2,0,10); System.out.println(test2[1]); //System.setOut(输出流)将out输入流重定位到该输出流， // print的则是该流的输出位置 //同理和setIn }]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[增强for循环的误区]]></title>
    <url>%2F2019%2F08%2F28%2F%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%AF%AF%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[增强for循环只是获得当前循环对象的值，不是对象的句柄，因此不能修改对象]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Calendar]]></title>
    <url>%2F2019%2F08%2F26%2FCalendar%2F</url>
    <content type="text"><![CDATA[public static void main(String args[]){ //Calendar是抽象类，需要实例化 Calendar calendar = Calendar.getInstance(); System.out.println(calendar.getTime()); //get()方法，返回当前calendar实例的类变量 //calendar的月份从0开始 System.out.println(calendar.get(Calendar.MONTH)); //set()方法，修改当前calendar实例的类变量 calendar.set(Calendar.DATE,27); System.out.println(calendar.getTime()); //getActuaMaximum得到实例当前字段的可能最大值 System.out.println(calendar.getActualMaximum(Calendar.MINUTE)); }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Calendar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2019%2F08%2F25%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型，即宽广的数据类型，用于使某个类，方法，接口，可以使用不同的数据类型，例：1.泛型类 修饰符 class name&lt;?&gt;{}2.泛型方法 修饰符 &lt;?&gt; 数据类型(){ }3.类型擦除：在使用泛型时，若没有指定类型，则默认为object4.类型限定： &lt;? extend type&gt;5.通配符： &lt;? , ?&gt;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[抽象类]]></title>
    <url>%2F2019%2F08%2F25%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类：1.含有抽象方法的类一定是抽象类，抽象类不一定含有抽象方法2.用abstract修饰3.可以有除了常量以外的变量接口：1.只有抽象方法2.只有常量（默认修饰为public,finally,static]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[向上转型和向下转型]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[向上转型：父类引用指向子类对象 Father father = new Son();向下转型：指向子类对象的父类引用变成子类引用 Father father = new Son(); if(father instanceof(Son())){ Son father1 = (Son)father; }]]></content>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的三个特点]]></title>
    <url>%2F2019%2F08%2F25%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[多态，继承，封装多态：要求：继承，重写，父类引用指向子类对象继承：构造方法不能被继承，在java中要么使用默认构造方法，要么重载构造方法]]></content>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重写和重载]]></title>
    <url>%2F2019%2F08%2F25%2F%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[1.重写(overriding)：针对于有继承关系的类方法，要求输入参数列表，返回参数类型（与父类返回参数相同或是父类返回参数类型的子类），访问修饰符不小于父类，不能抛出新的异常（父类引用指向子类对象，则调用子类重写过的方法），构造方法不能被继承，因此不能被重写，静态方法，属性可以被继承，而不能被重写，称为隐藏2.重载(overload)：要求参数列表必须不同，参数类型可以相同，可以抛出不同异常，修饰符无要求]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java语言概述]]></title>
    <url>%2F2019%2F08%2F25%2Fjava%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[1.特点：面向对象，一次编译，到处运行 2.应用：web, android,嵌入式，软件开发（不常用） 3.java虚拟机： 即JVM， java程序先编译成为字节码，再通过对应不同平台的jvm解释成机器码，实现了一次编译，到处运行。因此java是解释型语言（早期的，现在使用即时编译器？ 编译成特定系统编码），而编译型语言在运行前要编译生成对应的编译文件，使用编译文件运行 4.java的不同版本：j2se(标准版)，j2ee(企业版)，j2me(微型版，主要用于嵌入式) 5.什么是api: api是一种通用概念，java的api即java本身提供的许多强大的类，也叫做java类库 java应用程序接口 6.数据类型：3整型(short,int,long),字节型(byte),2浮点型(float,double),布尔型,复合数据类型 7.变量类型：基本类型（如基本数据类型的变量），直接为变量分配存储空间。引用类型（类，数组，接口），先分配引用空间，后分配数据空间 变量声明： int a; 初始化（定义）： a = 1 变量强制转换： x = 0.999;int a = (int) x ; 得到 a= 0.9，截断 java中不允许嵌套的代码块中相同的变量命名，c++中可以，例如 int a; { int a;//在java中报错 } 8.string:字符串，长度不可变，不可修改，可共享。当一个字符串不再被任何变量指向时，会自动被回收。使用”+”是生成新的字符串,常用方法length(),charAt(),是否包含方法：contains()，替换方法:replace(),分割方法:split() 码点和代码单元 ：一个码点是信息原子的单元。文本是一连串的码点，每一个码点表示一个符号，而码点由1个或多个信息单元组成. 在java中，? 是一个码点，由两个信息单元组成。 str.length()返回信息单元数量，str.codePointCount(0,str.length())返回码点数量 构建字符串： StringBuilder builder = new StringBuilder(); builder.append(..); String str = builder.toString; 9.stringBuilder和stringBuffer方法 10.什么是applet:在网页上运行的java程序 另起：1.数组有length这个属性，string有length()2.equals() :默认使用 ==来判断对象是否相同，而 == 只是判断对象的地址是否相同3.HashCode ：返回对象的hash值，常用于确定对象的存储地址或确定对象在散列表中的位置，两个对象hashcode相同，equals()不一定相同，equals()相同，hashcode一定相同另起： 术语： jdk : java development kit : 编写java程序的程序员使用的软件 jre : java runtime environment : 运行java程序的用户使用的软件 sdk : 描述98到06的jdk]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[怎样搭博客]]></title>
    <url>%2F2019%2F08%2F24%2F%E6%80%8E%E6%A0%B7%E6%90%AD%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本教程为本人经验和总结他人博客而来，使用hexo框架参考大佬总结的关于next主题配置教程：http://eternalzttz.com/hexo-next.html 1.下载和安装必要工具：下载，安装node.js与git,在cmd使用npm安装hexo框架2.使用hexo:1.创建一个用来存储和部署博客的文件夹：blog2.进入到这个文件夹，在cmd敲下命令： hexo init3.这样我们拥有了一个本地的博客文件夹，可以敲下命令： hexo s，在本地地址上预览博客3.完整和丰富博客：1.先认识博客文件夹中的各个文件夹：1.deploy-git: 将博客部署到github后自动生成2.node-modules: 存放安装的包的文件夹3.public :存放各种部署的文件4.source:其中的-post文件夹是存放博客文章的地方，其中的文件会被解析并放到public文件夹中，在source文件夹中，被命名为-开头的文件或文件夹会被忽略，非如此的则会当做-post一样的待遇处理5.-config文件是blog的各种配置文件2.通过修改博客文件夹中的文件，我们可以得到想要的效果####例如修改_config.yml文件中的site,可以改变标题，作者，描述，语言等等 3.给博客改变主题：1.初始化新的博客文件夹后，博客的初始主题是landscape,可以在站点_config.yml查看到博客主题名称2.在hexo的官网上，可以下载主题，下载好后，只要改变站点_config.yml文件中的theme即可4.完整博客：1.在初始化新博客后，主页上只有归档，和主页两项，可以安装新的主题，修改配置文件完整博客2.推荐博客主题：next3.在next主题下完整博客：1.改变布局：在主题配置文件中搜索:Schemes2.侧边栏优化：在主题_config.yml文件中搜索menu,选择想要添加的页面是否注释掉，但之后还要通过 hexo new page “name”生成相应页面3.添加搜索功能：首先，我们在终端进入blog的根目录下，执行以下命令：‘$ npm install hexo-generator-searchdb –save’ 接着，我们进入站点配置文件_config.yml,在最后新增以下内容：search: path: search.xml field: post format: html limit: 10000最后，打开主题配置文件_config.yml,搜索local_search,其值改为true：local_search: enable: true4.添加头像：准备一张图片，存储入themes/next/source/images/文件夹下，然后在主题配置文件中搜索avatar,修改url为图片地址avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. - url: /images/avatar.gif + url: /images/header.jpg #图片的地址 # If true, the avatar would be dispalyed in circle. rounded: false #设置图片是否为圆形，当图片为正方形时为圆，否则为椭圆 # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 #图片的透明度 # If true, the avatar would be rotated with the cursor. rotated: false #设置鼠标移到图片上后头像是否转动4.将博客部署到github上：1.创建一个github仓库，仓库名是用户名.github.io2.在cmd下进入blog文件夹，输入命令:cnpm install –save-hexo-deployer-git3.进入站点_config.yml文件，修改deploy部分：type: git repo: 仓库地址4.接着输入账号和密码即可，这样就部署成功了5.博客添加文章：：hexo new “”：部署到远端： hexo d]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[articlesb]]></title>
    <url>%2F2019%2F08%2F19%2Farticlesb%2F</url>
    <content type="text"></content>
  </entry>
</search>

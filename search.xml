<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何使图片居中]]></title>
    <url>%2F2019%2F10%2F16%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[设置 且Center中要设置width,否则无效 设置]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css学习]]></title>
    <url>%2F2019%2F10%2F15%2Fcss%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[div标签控制其他元素位置1. //创建//css的三种方法：外部&lt;内部&lt;内联（慎用内联）. css 选择器 ： id,class3. css 控制背景：1.背景图片：平铺：repete 来充满避免背景图片没有容器大size 控制大小attachment: 控制是否滑动，fixed不滑动4.css控制链接格式a:link(未点击) visited(点击后) hover(鼠标移动到链接上) active(点击时)5. css盒子模型：盒子总宽度：（border:边框+padding:内边距+width:内容宽度) 当我们设置一个块时，还要考虑外边距(margin)，即块与浏览器的距离。所有的html标签可以看做盒子6. css嵌套： p{} (所有p标签) .t{}(所有class为t) .t p{} (所有class为t的元素内的p元素) p.t{} (所有class为t的p元素)7. css 显示1.隐藏的方法： p.hidden(visibilty: hidde):隐藏但仍占有空间，p.hidden(display:none):隐藏，不占空间2.display:block,in-line8. css 定位： 使用position, z-index决定了显示的前后位置9. css float : 控制元素当窗口大小不够时的浮动方向]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2F2019%2F09%2F16%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1. 全局配置文件：app.json1. pages：用于添加页面2. tabBars:添加底部按钮2. 页面配置：page.json3. 前端开发要阅读文档即可4. 前端：wx:keywx:for={}绑定一个数组 wx:for-item绑定当前数组的一个变量名每个页面有id,就是加载时的options中]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css]]></title>
    <url>%2F2019%2F09%2F08%2Fcss%2F</url>
    <content type="text"><![CDATA[1.概念：css，即层叠样式表，是一种语言，可用来设定html中标签的各式2.css的引用： 内嵌样式表：style = 文档内嵌入：在&lt;\head&gt;标签内设定&lt;\style&gt;标签，还可以使用类型选择器 外部文档调用：在&lt;\head&gt;标签中链接3.类型选择器： 1.*：全部属性 2.类： 在需要套用格式的标签中套用class = 3.id 4.标签属性 5。根据属性选择：例如href4.类型选择器中可以修改的属性：颜色，字体，边框（边框可以简写属性,可以给某个标签设置边框，默认style是none,即不显示 learncss –&gt; *{ font: size 30px; color:darkorange } .class1{ color:darkslategray; } #l1{ color: blue } test fuck fuck u sss 5.css设置文本格式： 1.设置对齐方式：text-align 2.direction对中文无效. 3.设置间距：text-spacing,word-spacing 4.行高：line-height 5.首行缩进：test-indent 6.字体样式：font-family 7.改变字体大小写：text-transform6.css过渡： 1.使用标签的hover: p:hover{} 2.设置触发过渡的时间：transition-delay 3.设置动画时间：transition-duration 4.设置采用延迟过渡的属性：transition-propertry]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web 的基础知识]]></title>
    <url>%2F2019%2F09%2F03%2Fweb-%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1. web:1. web资源：动态（程序生成数据，有交互功能），静态（数据不变）2. web应用：多个web资源放到同一个目录，要想供外界使用，就放到web服务器上]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[静态链表]]></title>
    <url>%2F2019%2F09%2F02%2F%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[概念 ： c语言中，使用数组结构的，结合顺序和非顺序特点的数据结构 逻辑结构 ： 先初始化一个超大数组（结构体的数组，结构体包括两个变量：data ,cur(指向下一个节点的数组序号)，0号节点是备用链表的头 创建：创建这个数组，然后每个节点的默认data是-1，cur是i+1（最后一个节点的cur是0） 初始化（其实应该是从备用列表中，取一个新节点到可用链表中（可用链表和备用链表在一个数组中），除了0号节点）： int mallocarr(*arr){ int i = arr[0];//此时0号节点指向的是备用节点的第一位 if(arr[0]){ arr[0].cur = arr[i].cur } return i; }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python IO]]></title>
    <url>%2F2019%2F09%2F01%2Fpython-IO%2F</url>
    <content type="text"><![CDATA[打开文件： #读取 f = open(url,’r’) #写入（覆盖） f = open(url.’w’) ##这样就是创建新文件 #追加 f = open(url,’a’) 一次性读：read 创建新的文件目录： import os os.mkdirs(ur)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python错误及调试]]></title>
    <url>%2F2019%2F09%2F01%2Fpython%E9%94%99%E8%AF%AF%E5%8F%8A%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[格式： try: except errorname as e finally: 抛出错误： raise error]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python类与实例]]></title>
    <url>%2F2019%2F09%2F01%2Fpython%E7%B1%BB%E4%B8%8E%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[创建一个类 class name(): # (继承对象，可以多继承) 必须有 def /init__(self): 要限制外界访问类的某个变量，可以使变量名开头为双下划线__ 可以直接为实例对象添加属性和方法： s = name() s.score = 90 也可以直接为类添加属性和方法，但可以使用slots来限定实例对象能添加的属性名字 class name(): def __init__(): __slots__ = (&quot;name&quot;) #绑定的变量名只能是name 获取对象的所有属性和方法： dir() 防止外界直接查看或修改实例的属性： 构造get,set方法，还可以用@propetry修饰它们，使这些方法可以像属性一样调用，前提是方法名一致 class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError(&apos;score must be an integer!&apos;) if value &lt; 0 or value &gt; 100: raise ValueError(&apos;score must between 0 ~ 100!&apos;) self._score = value]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python生成器]]></title>
    <url>%2F2019%2F08%2F31%2Fpython%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[what is generator???一种惰性的计算机制，只有调用next（generator)时才会计算调用其中元素定义一个生成器： (x for x in range(0,11)) def name(): for i in range(0,11):yield i使用生成器：a = name()next(a) ## 调用其中一个元素，从投至尾]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python is and ==]]></title>
    <url>%2F2019%2F08%2F31%2Fpython-is-and%2F</url>
    <content type="text"><![CDATA[is : 比较引用地址是否相同== ： 比较对象内容是否相同]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2F2019%2F08%2F31%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.定义函数: def name(): pass这是定义了一个空函数2.函数只有一个函数，但可以用一个元组返回多个值 def name(): … return x,y x,y = name()3.参数检查： def name(x) if not (isinstanceof(x,int)): raise TypeError(“bad type”)4.默认参数 def name(x,y=1)5.可变参数 def name(x,y): for k in y: print(y) #y是一个元组 name(x,y) y是一个元组，将y解析成一个个参数 6.关键字参数 def name(x,**y): pass name(x,gentle = “a”)##传入一个键值对]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[collection与collections]]></title>
    <url>%2F2019%2F08%2F31%2Fcollection%E4%B8%8Ecollections%2F</url>
    <content type="text"><![CDATA[collection : java.util下的一个接口collections : java.util下的一个集合类]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python正则表达式]]></title>
    <url>%2F2019%2F08%2F30%2Fpython%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式： 用于检查符合某种模式的字符串匹配 python中使用re模块]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表 元组 字典 集合]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%88%97%E8%A1%A8-%E5%85%83%E7%BB%84-%E5%AD%97%E5%85%B8-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[列表1.创建列表： 1.a = [] 2.列表解析式 a = [value for value in range(1,11)] 3.a = list(range(1,11)) 4.使用切片复制 a = b[:]2.对列表操作：添加add 插入insert 删除remove 弹出pop 连接 extend(another list) 排序sort() 得到排序而不是对列表对象直接操作sorted() 反转reverse() 元组 创建元组： () 元组不可修改 字典 创建 ：a ={} 添加键值对 :a[key] = value 删除 : del a[key] 返回键值.keys() 返回值.values() 返回字典中的一个键和值.items() 集合不能使用索引，分片，因为其是无序的]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python输入输出]]></title>
    <url>%2F2019%2F08%2F29%2Fpython%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[1.打印： py2: print”” py3:print(“”) [去掉空格：print(“”,end=””) 打印格式化： b = “1{}2{}3{}” print(b.format(1,2,3))]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python String]]></title>
    <url>%2F2019%2F08%2F29%2Fpython-String%2F</url>
    <content type="text"><![CDATA[1.删除字符串中空白：头：lstrip() 尾： rstrip() 两端: strip()]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python爬虫]]></title>
    <url>%2F2019%2F08%2F28%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[爬虫的定义1.一段程序 2. 模范浏览器浏览网页 3. 自动搜集数据步骤：1.调用模块，爬取网页文件（html)2.使用正则表达式处理文件3.存储数据]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[StringBuilder和StringBuffer]]></title>
    <url>%2F2019%2F08%2F28%2FStringBuilder%E5%92%8CStringBuffer%2F</url>
    <content type="text"><![CDATA[1.StringBuilder速度更快，但不支持线程安全2.两者都支持原地修改字符串，而不是生成新的对象 public static void main(String args[]){ StringBuilder test = new StringBuilder(&quot;123&quot;); test.append(&quot;a&quot;); test.append(4); System.out.println(test); test.delete(1,2);//不包括end System.out.println(test); System.out.println(test.subSequence(0,1));//不包括end test.setLength(2);//从前到后截断 System.out.println(test); System.out.println(test.lastIndexOf(&quot;1234&quot;)); }]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[System类的一些方法]]></title>
    <url>%2F2019%2F08%2F28%2FSystem%E7%B1%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[public static void main(String args[]){ //列出系统的所有属性，getPropertries()返回propertries类 //System.getProperties().list(System.out); //用毫秒为单位得到返回类型为long的当前时间 //System.out.println(System.currentTimeMillis()); int[] test1 = new int[10]; for (int i =0;i&lt;10;i++){ test1[i] = i; } //数组的复制 System.arraycopy(test1,0,test2,0,10); System.out.println(test2[1]); //System.setOut(输出流)将out输入流重定位到该输出流， // print的则是该流的输出位置 //同理和setIn }]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[增强for循环的误区]]></title>
    <url>%2F2019%2F08%2F28%2F%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%AF%AF%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[增强for循环只是获得当前循环对象的值，不是对象的句柄，因此不能修改对象]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Calendar]]></title>
    <url>%2F2019%2F08%2F26%2FCalendar%2F</url>
    <content type="text"><![CDATA[public static void main(String args[]){ //Calendar是抽象类，需要实例化 Calendar calendar = Calendar.getInstance(); System.out.println(calendar.getTime()); //get()方法，返回当前calendar实例的类变量 //calendar的月份从0开始 System.out.println(calendar.get(Calendar.MONTH)); //set()方法，修改当前calendar实例的类变量 calendar.set(Calendar.DATE,27); System.out.println(calendar.getTime()); //getActuaMaximum得到实例当前字段的可能最大值 System.out.println(calendar.getActualMaximum(Calendar.MINUTE)); }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Calendar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2019%2F08%2F25%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型，即宽广的数据类型，用于使某个类，方法，接口，可以使用不同的数据类型，例：1.泛型类 修饰符 class name&lt;?&gt;{}2.泛型方法 修饰符 &lt;?&gt; 数据类型(){ }3.类型擦除：在使用泛型时，若没有指定类型，则默认为object4.类型限定： &lt;? extend type&gt;5.通配符： &lt;? , ?&gt;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类]]></title>
    <url>%2F2019%2F08%2F25%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类：1.含有抽象方法的类一定是抽象类，抽象类不一定含有抽象方法2.用abstract修饰3.可以有除了常量以外的变量接口：1.只有抽象方法2.只有常量（默认修饰为public,finally,static]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向上转型和向下转型]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[向上转型：父类引用指向子类对象 Father father = new Son();向下转型：指向子类对象的父类引用变成子类引用 Father father = new Son(); if(father instanceof(Son())){ Son father1 = (Son)father; }]]></content>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的三个特点]]></title>
    <url>%2F2019%2F08%2F25%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[多态，继承，封装多态：要求：继承，重写，父类引用指向子类对象继承：构造方法不能被继承，在java中要么使用默认构造方法，要么重载构造方法]]></content>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重写和重载]]></title>
    <url>%2F2019%2F08%2F25%2F%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[1.重写(overriding)：针对于有继承关系的类方法，要求输入参数列表，返回参数类型（与父类返回参数相同或是父类返回参数类型的子类），访问修饰符不小于父类，不能抛出新的异常（父类引用指向子类对象，则调用子类重写过的方法），构造方法不能被继承，因此不能被重写，静态方法，属性可以被继承，而不能被重写，称为隐藏2.重载(overload)：要求参数列表必须不同，参数类型可以相同，可以抛出不同异常，修饰符无要求]]></content>
      <tags>
        <tag>java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java语言概述]]></title>
    <url>%2F2019%2F08%2F25%2Fjava%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[1.特点：面向对象，一次编译，到处运行2.应用：web, android,嵌入式，软件开发（不常用）3.java虚拟机： 即JVM， java程序先编译成为字节码，再通过对应不同平台的jvm解释成机器码，实现了一次编译，到处运行4.java的不同版本：j2se(标准版)，j2ee(企业版)，j2me(微型版，主要用于嵌入式)5.什么是api: api是一种通用概念，java的api即java本身提供的许多强大的类，也叫做java类库6.数据类型：3整型(short,int,long),字节型(byte),2浮点型(float,double),布尔型,复合数据类型7.变量类型：基本类型（如基本数据类型的变量），直接为变量分配存储空间。引用类型（类，数组，接口），先分配引用空间，后分配数据空间8.string:字符串，长度不可变，使用”+”是生成新的字符串,常用方法length(),charAt(),是否包含方法：contains()，替换方法:replace(),分割方法:split()9.stringBuilder和stringBuffer方法另起：1.数组有length这个属性，string有length()2.equals() :默认使用 ==来判断对象是否相同，而 == 只是判断对象的地址是否相同3.HashCode ：返回对象的hash值，常用于确定对象的存储地址或确定对象在散列表中的位置，两个对象hashcode相同，equals()不一定相同，equals()相同，hashcode一定相同]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样搭博客]]></title>
    <url>%2F2019%2F08%2F24%2F%E6%80%8E%E6%A0%B7%E6%90%AD%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本教程为本人经验和总结他人博客而来，使用hexo框架参考大佬总结的关于next主题配置教程：http://eternalzttz.com/hexo-next.html 1.下载和安装必要工具：下载，安装node.js与git,在cmd使用npm安装hexo框架2.使用hexo:1.创建一个用来存储和部署博客的文件夹：blog2.进入到这个文件夹，在cmd敲下命令： hexo init3.这样我们拥有了一个本地的博客文件夹，可以敲下命令： hexo s，在本地地址上预览博客3.完整和丰富博客：1.先认识博客文件夹中的各个文件夹：1.deploy-git: 将博客部署到github后自动生成2.node-modules: 存放安装的包的文件夹3.public :存放各种部署的文件4.source:其中的-post文件夹是存放博客文章的地方，其中的文件会被解析并放到public文件夹中，在source文件夹中，被命名为-开头的文件或文件夹会被忽略，非如此的则会当做-post一样的待遇处理5.-config文件是blog的各种配置文件2.通过修改博客文件夹中的文件，我们可以得到想要的效果####例如修改_config.yml文件中的site,可以改变标题，作者，描述，语言等等 3.给博客改变主题：1.初始化新的博客文件夹后，博客的初始主题是landscape,可以在站点_config.yml查看到博客主题名称2.在hexo的官网上，可以下载主题，下载好后，只要改变站点_config.yml文件中的theme即可4.完整博客：1.在初始化新博客后，主页上只有归档，和主页两项，可以安装新的主题，修改配置文件完整博客2.推荐博客主题：next3.在next主题下完整博客：1.改变布局：在主题配置文件中搜索:Schemes2.侧边栏优化：在主题_config.yml文件中搜索menu,选择想要添加的页面是否注释掉，但之后还要通过 hexo new page “name”生成相应页面3.添加搜索功能：首先，我们在终端进入blog的根目录下，执行以下命令：‘$ npm install hexo-generator-searchdb –save’ 接着，我们进入站点配置文件_config.yml,在最后新增以下内容：search: path: search.xml field: post format: html limit: 10000最后，打开主题配置文件_config.yml,搜索local_search,其值改为true：local_search: enable: true4.添加头像：准备一张图片，存储入themes/next/source/images/文件夹下，然后在主题配置文件中搜索avatar,修改url为图片地址avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. - url: /images/avatar.gif + url: /images/header.jpg #图片的地址 # If true, the avatar would be dispalyed in circle. rounded: false #设置图片是否为圆形，当图片为正方形时为圆，否则为椭圆 # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 #图片的透明度 # If true, the avatar would be rotated with the cursor. rotated: false #设置鼠标移到图片上后头像是否转动4.将博客部署到github上：1.创建一个github仓库，仓库名是用户名.github.io2.在cmd下进入blog文件夹，输入命令:cnpm install –save-hexo-deployer-git3.进入站点_config.yml文件，修改deploy部分：type: git repo: 仓库地址4.接着输入账号和密码即可，这样就部署成功了5.博客添加文章：：hexo new “”：部署到远端： hexo d]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[articleTest]]></title>
    <url>%2F2019%2F08%2F17%2FarticleTest%2F</url>
    <content type="text"><![CDATA[welcome: 超级无敌可爱居居妹人家好想你啊嘿嘿嘿]]></content>
      <tags>
        <tag>test1</tag>
        <tag>test2</tag>
      </tags>
  </entry>
</search>
